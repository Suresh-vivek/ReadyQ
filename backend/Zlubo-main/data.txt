Home v6.22.3 | React RoutermainBranchesmain (6.22.3)devVersions6.22.3v4/5.xv3.x Light Dark SystemNavigationGetting StartedFeature Overview Tutorial Examples FAQs Main Concepts Changelog UpgradingMigrating to RouterProvider Upgrading from v5 Migrating from @reach/router RoutersPicking a Router 🆕createBrowserRouter 🆕createHashRouter 🆕createMemoryRouter 🆕createStaticHandler 🆕createStaticRouter 🆕RouterProvider 🆕StaticRouterProvider 🆕Router ComponentsBrowserRouter HashRouter MemoryRouter NativeRouter Router StaticRouter RouteRoute 🆕action 🆕errorElement 🆕hydrateFallbackElement 🆕lazy 🆕loader 🆕shouldRevalidate 🆕ComponentsAwait 🆕Form 🆕Link Link (RN) NavLink Navigate Outlet Route Routes ScrollRestoration 🆕HooksuseActionData 🆕useAsyncError 🆕useAsyncValue 🆕useBeforeUnload 🆕useBlocker useFetcher 🆕useFetchers 🆕useFormAction 🆕useHref useInRouterContext useLinkClickHandler useLinkPressHandler useLoaderData 🆕useLocation useMatch useMatches 🆕useNavigate useNavigation 🆕useNavigationType useOutlet useOutletContext useParams unstable_usePrompt useResolvedPath useRevalidator 🆕useRouteError 🆕useRouteLoaderData 🆕useRoutes useSearchParams useSearchParams (RN) useSubmit 🆕unstable_useViewTransitionState Fetch Utilitiesjson 🆕redirect 🆕redirectDocument 🆕UtilitiescreateRoutesFromChildren createRoutesFromElements createSearchParams defer 🆕generatePath isRouteErrorResponse 🆕Location matchPath matchRoutes renderMatches resolvePath GuidesServer-Side Rendering Contributing API Development Strategy 🆕Data Library Integration Deferred Data 🆕Working With FormData 🆕Index Query Param 🆕Getting StartedFeature Overview Tutorial Examples FAQs Main Concepts Changelog UpgradingMigrating to RouterProvider Upgrading from v5 Migrating from @reach/router RoutersPicking a Router 🆕createBrowserRouter 🆕createHashRouter 🆕createMemoryRouter 🆕createStaticHandler 🆕createStaticRouter 🆕RouterProvider 🆕StaticRouterProvider 🆕Router ComponentsBrowserRouter HashRouter MemoryRouter NativeRouter Router StaticRouter RouteRoute 🆕action 🆕errorElement 🆕hydrateFallbackElement 🆕lazy 🆕loader 🆕shouldRevalidate 🆕ComponentsAwait 🆕Form 🆕Link Link (RN) NavLink Navigate Outlet Route Routes ScrollRestoration 🆕HooksuseActionData 🆕useAsyncError 🆕useAsyncValue 🆕useBeforeUnload 🆕useBlocker useFetcher 🆕useFetchers 🆕useFormAction 🆕useHref useInRouterContext useLinkClickHandler useLinkPressHandler useLoaderData 🆕useLocation useMatch useMatches 🆕useNavigate useNavigation 🆕useNavigationType useOutlet useOutletContext useParams unstable_usePrompt useResolvedPath useRevalidator 🆕useRouteError 🆕useRouteLoaderData 🆕useRoutes useSearchParams useSearchParams (RN) useSubmit 🆕unstable_useViewTransitionState Fetch Utilitiesjson 🆕redirect 🆕redirectDocument 🆕UtilitiescreateRoutesFromChildren createRoutesFromElements createSearchParams defer 🆕generatePath isRouteErrorResponse 🆕Location matchPath matchRoutes renderMatches resolvePath GuidesServer-Side Rendering Contributing API Development Strategy 🆕Data Library Integration Deferred Data 🆕Working With FormData 🆕Index Query Param 🆕What's New in 6.4?v6.4 is our most exciting release yet with new data abstractions for reads, writes, and navigation hooks to easily keep your UI in sync with your data. The new feature overview will catch you up.I'm NewStart with the tutorial. It will quickly introduce you to the primary features of React Router: from configuring routes, to loading and mutating data, to pending and optimistic UI.I'm on v5The migration guide will help you migrate incrementally and keep shipping along the way. Or, do it all in one yolo commit! Either way, we've got you covered to start using the new features right away.I'm Stuck!Running into a problem? Chances are you're not the first! Explore common questions about React Router v6.© Remix Software, Inc.•Brand•Docs and examples CC 4.0

Home (dev branch) | React RouterdevBranchesmain (6.22.3)devVersions6.22.3v4/5.xv3.x Light Dark SystemViewing docs for dev branch, not the latest release. View latestNavigationGetting StartedFeature Overview Tutorial Examples FAQs Main Concepts UpgradingMigrating to RouterProvider Upgrading from v5 Migrating from @reach/router RoutersPicking a Router 🆕createBrowserRouter 🆕createHashRouter 🆕createMemoryRouter 🆕createStaticHandler 🆕createStaticRouter 🆕RouterProvider 🆕StaticRouterProvider 🆕Router ComponentsBrowserRouter HashRouter MemoryRouter NativeRouter Router StaticRouter RouteRoute 🆕action 🆕errorElement 🆕hydrateFallbackElement 🆕lazy 🆕loader 🆕shouldRevalidate 🆕ComponentsAwait 🆕Form 🆕Link Link (RN) NavLink Navigate Outlet Route Routes ScrollRestoration 🆕HooksuseActionData 🆕useAsyncError 🆕useAsyncValue 🆕useBeforeUnload 🆕useBlocker useFetcher 🆕useFetchers 🆕useFormAction 🆕useHref useInRouterContext useLinkClickHandler useLinkPressHandler useLoaderData 🆕useLocation useMatch useMatches 🆕useNavigate useNavigation 🆕useNavigationType useOutlet useOutletContext useParams unstable_usePrompt useResolvedPath useRevalidator 🆕useRouteError 🆕useRouteLoaderData 🆕useRoutes useSearchParams useSearchParams (RN) useSubmit 🆕unstable_useViewTransitionState Fetch Utilitiesjson 🆕redirect 🆕redirectDocument 🆕UtilitiescreateRoutesFromChildren createRoutesFromElements createSearchParams defer 🆕generatePath isRouteErrorResponse 🆕Location matchPath matchRoutes renderMatches resolvePath GuidesServer-Side Rendering Contributing API Development Strategy 🆕Data Library Integration Deferred Data 🆕Working With FormData 🆕Index Query Param 🆕Getting StartedFeature Overview Tutorial Examples FAQs Main Concepts UpgradingMigrating to RouterProvider Upgrading from v5 Migrating from @reach/router RoutersPicking a Router 🆕createBrowserRouter 🆕createHashRouter 🆕createMemoryRouter 🆕createStaticHandler 🆕createStaticRouter 🆕RouterProvider 🆕StaticRouterProvider 🆕Router ComponentsBrowserRouter HashRouter MemoryRouter NativeRouter Router StaticRouter RouteRoute 🆕action 🆕errorElement 🆕hydrateFallbackElement 🆕lazy 🆕loader 🆕shouldRevalidate 🆕ComponentsAwait 🆕Form 🆕Link Link (RN) NavLink Navigate Outlet Route Routes ScrollRestoration 🆕HooksuseActionData 🆕useAsyncError 🆕useAsyncValue 🆕useBeforeUnload 🆕useBlocker useFetcher 🆕useFetchers 🆕useFormAction 🆕useHref useInRouterContext useLinkClickHandler useLinkPressHandler useLoaderData 🆕useLocation useMatch useMatches 🆕useNavigate useNavigation 🆕useNavigationType useOutlet useOutletContext useParams unstable_usePrompt useResolvedPath useRevalidator 🆕useRouteError 🆕useRouteLoaderData 🆕useRoutes useSearchParams useSearchParams (RN) useSubmit 🆕unstable_useViewTransitionState Fetch Utilitiesjson 🆕redirect 🆕redirectDocument 🆕UtilitiescreateRoutesFromChildren createRoutesFromElements createSearchParams defer 🆕generatePath isRouteErrorResponse 🆕Location matchPath matchRoutes renderMatches resolvePath GuidesServer-Side Rendering Contributing API Development Strategy 🆕Data Library Integration Deferred Data 🆕Working With FormData 🆕Index Query Param 🆕What's New in 6.4?v6.4 is our most exciting release yet with new data abstractions for reads, writes, and navigation hooks to easily keep your UI in sync with your data. The new feature overview will catch you up.I'm NewStart with the tutorial. It will quickly introduce you to the primary features of React Router: from configuring routes, to loading and mutating data, to pending and optimistic UI.I'm on v5The migration guide will help you migrate incrementally and keep shipping along the way. Or, do it all in one yolo commit! Either way, we've got you covered to start using the new features right away.I'm Stuck!Running into a problem? Chances are you're not the first! Explore common questions about React Router v6.© Remix Software, Inc.•Brand•Docs and examples CC 4.0

Home v6.22.3 | React Router6.22.3Branchesmain (6.22.3)devVersions6.22.3v4/5.xv3.x Light Dark SystemNavigationGetting StartedFeature Overview Tutorial Examples FAQs Main Concepts UpgradingMigrating to RouterProvider Upgrading from v5 Migrating from @reach/router RoutersPicking a Router 🆕createBrowserRouter 🆕createHashRouter 🆕createMemoryRouter 🆕createStaticHandler 🆕createStaticRouter 🆕RouterProvider 🆕StaticRouterProvider 🆕Router ComponentsBrowserRouter HashRouter MemoryRouter NativeRouter Router StaticRouter RouteRoute 🆕action 🆕errorElement 🆕hydrateFallbackElement 🆕lazy 🆕loader 🆕shouldRevalidate 🆕ComponentsAwait 🆕Form 🆕Link Link (RN) NavLink Navigate Outlet Route Routes ScrollRestoration 🆕HooksuseActionData 🆕useAsyncError 🆕useAsyncValue 🆕useBeforeUnload 🆕useBlocker useFetcher 🆕useFetchers 🆕useFormAction 🆕useHref useInRouterContext useLinkClickHandler useLinkPressHandler useLoaderData 🆕useLocation useMatch useMatches 🆕useNavigate useNavigation 🆕useNavigationType useOutlet useOutletContext useParams unstable_usePrompt useResolvedPath useRevalidator 🆕useRouteError 🆕useRouteLoaderData 🆕useRoutes useSearchParams useSearchParams (RN) useSubmit 🆕unstable_useViewTransitionState Fetch Utilitiesjson 🆕redirect 🆕redirectDocument 🆕UtilitiescreateRoutesFromChildren createRoutesFromElements createSearchParams defer 🆕generatePath isRouteErrorResponse 🆕Location matchPath matchRoutes renderMatches resolvePath GuidesServer-Side Rendering Contributing API Development Strategy 🆕Data Library Integration Deferred Data 🆕Working With FormData 🆕Index Query Param 🆕Getting StartedFeature Overview Tutorial Examples FAQs Main Concepts UpgradingMigrating to RouterProvider Upgrading from v5 Migrating from @reach/router RoutersPicking a Router 🆕createBrowserRouter 🆕createHashRouter 🆕createMemoryRouter 🆕createStaticHandler 🆕createStaticRouter 🆕RouterProvider 🆕StaticRouterProvider 🆕Router ComponentsBrowserRouter HashRouter MemoryRouter NativeRouter Router StaticRouter RouteRoute 🆕action 🆕errorElement 🆕hydrateFallbackElement 🆕lazy 🆕loader 🆕shouldRevalidate 🆕ComponentsAwait 🆕Form 🆕Link Link (RN) NavLink Navigate Outlet Route Routes ScrollRestoration 🆕HooksuseActionData 🆕useAsyncError 🆕useAsyncValue 🆕useBeforeUnload 🆕useBlocker useFetcher 🆕useFetchers 🆕useFormAction 🆕useHref useInRouterContext useLinkClickHandler useLinkPressHandler useLoaderData 🆕useLocation useMatch useMatches 🆕useNavigate useNavigation 🆕useNavigationType useOutlet useOutletContext useParams unstable_usePrompt useResolvedPath useRevalidator 🆕useRouteError 🆕useRouteLoaderData 🆕useRoutes useSearchParams useSearchParams (RN) useSubmit 🆕unstable_useViewTransitionState Fetch Utilitiesjson 🆕redirect 🆕redirectDocument 🆕UtilitiescreateRoutesFromChildren createRoutesFromElements createSearchParams defer 🆕generatePath isRouteErrorResponse 🆕Location matchPath matchRoutes renderMatches resolvePath GuidesServer-Side Rendering Contributing API Development Strategy 🆕Data Library Integration Deferred Data 🆕Working With FormData 🆕Index Query Param 🆕What's New in 6.4?v6.4 is our most exciting release yet with new data abstractions for reads, writes, and navigation hooks to easily keep your UI in sync with your data. The new feature overview will catch you up.I'm NewStart with the tutorial. It will quickly introduce you to the primary features of React Router: from configuring routes, to loading and mutating data, to pending and optimistic UI.I'm on v5The migration guide will help you migrate incrementally and keep shipping along the way. Or, do it all in one yolo commit! Either way, we've got you covered to start using the new features right away.I'm Stuck!Running into a problem? Chances are you're not the first! Explore common questions about React Router v6.© Remix Software, Inc.•Brand•Docs and examples CC 4.0

Feature Overview v6.22.3 | React Router6.22.3Branchesmain (6.22.3)devVersions6.22.3v4/5.xv3.x Light Dark SystemFeature OverviewGetting StartedFeature Overview Tutorial Examples FAQs Main Concepts UpgradingMigrating to RouterProvider Upgrading from v5 Migrating from @reach/router RoutersPicking a Router 🆕createBrowserRouter 🆕createHashRouter 🆕createMemoryRouter 🆕createStaticHandler 🆕createStaticRouter 🆕RouterProvider 🆕StaticRouterProvider 🆕Router ComponentsBrowserRouter HashRouter MemoryRouter NativeRouter Router StaticRouter RouteRoute 🆕action 🆕errorElement 🆕hydrateFallbackElement 🆕lazy 🆕loader 🆕shouldRevalidate 🆕ComponentsAwait 🆕Form 🆕Link Link (RN) NavLink Navigate Outlet Route Routes ScrollRestoration 🆕HooksuseActionData 🆕useAsyncError 🆕useAsyncValue 🆕useBeforeUnload 🆕useBlocker useFetcher 🆕useFetchers 🆕useFormAction 🆕useHref useInRouterContext useLinkClickHandler useLinkPressHandler useLoaderData 🆕useLocation useMatch useMatches 🆕useNavigate useNavigation 🆕useNavigationType useOutlet useOutletContext useParams unstable_usePrompt useResolvedPath useRevalidator 🆕useRouteError 🆕useRouteLoaderData 🆕useRoutes useSearchParams useSearchParams (RN) useSubmit 🆕unstable_useViewTransitionState Fetch Utilitiesjson 🆕redirect 🆕redirectDocument 🆕UtilitiescreateRoutesFromChildren createRoutesFromElements createSearchParams defer 🆕generatePath isRouteErrorResponse 🆕Location matchPath matchRoutes renderMatches resolvePath GuidesServer-Side Rendering Contributing API Development Strategy 🆕Data Library Integration Deferred Data 🆕Working With FormData 🆕Index Query Param 🆕Getting StartedFeature Overview Tutorial Examples FAQs Main Concepts UpgradingMigrating to RouterProvider Upgrading from v5 Migrating from @reach/router RoutersPicking a Router 🆕createBrowserRouter 🆕createHashRouter 🆕createMemoryRouter 🆕createStaticHandler 🆕createStaticRouter 🆕RouterProvider 🆕StaticRouterProvider 🆕Router ComponentsBrowserRouter HashRouter MemoryRouter NativeRouter Router StaticRouter RouteRoute 🆕action 🆕errorElement 🆕hydrateFallbackElement 🆕lazy 🆕loader 🆕shouldRevalidate 🆕ComponentsAwait 🆕Form 🆕Link Link (RN) NavLink Navigate Outlet Route Routes ScrollRestoration 🆕HooksuseActionData 🆕useAsyncError 🆕useAsyncValue 🆕useBeforeUnload 🆕useBlocker useFetcher 🆕useFetchers 🆕useFormAction 🆕useHref useInRouterContext useLinkClickHandler useLinkPressHandler useLoaderData 🆕useLocation useMatch useMatches 🆕useNavigate useNavigation 🆕useNavigationType useOutlet useOutletContext useParams unstable_usePrompt useResolvedPath useRevalidator 🆕useRouteError 🆕useRouteLoaderData 🆕useRoutes useSearchParams useSearchParams (RN) useSubmit 🆕unstable_useViewTransitionState Fetch Utilitiesjson 🆕redirect 🆕redirectDocument 🆕UtilitiescreateRoutesFromChildren createRoutesFromElements createSearchParams defer 🆕generatePath isRouteErrorResponse 🆕Location matchPath matchRoutes renderMatches resolvePath GuidesServer-Side Rendering Contributing API Development Strategy 🆕Data Library Integration Deferred Data 🆕Working With FormData 🆕Index Query Param 🆕On this pageClient Side RoutingNested RoutesDynamic SegmentsRanked Route MatchingActive LinksRelative LinksData LoadingRedirectsPending Navigation UISkeleton UI with <Suspense>Data MutationsData RevalidationBusy IndicatorsOptimistic UIData FetchersRace Condition HandlingError HandlingScroll RestorationWeb Standard APIsSearch ParamsLocation StateOn this pageClient Side RoutingNested RoutesDynamic SegmentsRanked Route MatchingActive LinksRelative LinksData LoadingRedirectsPending Navigation UISkeleton UI with <Suspense>Data MutationsData RevalidationBusy IndicatorsOptimistic UIData FetchersRace Condition HandlingError HandlingScroll RestorationWeb Standard APIsSearch ParamsLocation StateFeature Overview
Client Side Routing
React Router enables "client side routing".
In traditional websites, the browser requests a document from a web server, downloads and evaluates CSS and JavaScript assets, and renders the HTML sent from the server. When the user clicks a link, it starts the process all over again for a new page.
Client side routing allows your app to update the URL from a link click without making another request for another document from the server. Instead, your app can immediately render some new UI and make data requests with fetch to update the page with new information.
This enables faster user experiences because the browser doesn't need to request an entirely new document or re-evaluate CSS and JavaScript assets for the next page. It also enables more dynamic user experiences with things like animation.
Client side routing is enabled by creating a Router and linking/submitting to pages with Link and <Form>:
import * as React from "react";
import { createRoot } from "react-dom/client";
import {
  createBrowserRouter,
  RouterProvider,
  Route,
  Link,
} from "react-router-dom";

const router = createBrowserRouter([
  {
    path: "/",
    element: (
      <div>
        <h1>Hello World</h1>
        <Link to="about">About Us</Link>
      </div>
    ),
  },
  {
    path: "about",
    element: <div>About</div>,
  },
]);

createRoot(document.getElementById("root")).render(
  <RouterProvider router={router} />
);

Nested Routes
Nested Routing is the general idea of coupling segments of the URL to component hierarchy and data. React Router's nested routes were inspired by the routing system in Ember.js circa 2014. The Ember team realized that in nearly every case, segments of the URL determine:

The layouts to render on the page
The data dependencies of those layouts

React Router embraces this convention with APIs for creating nested layouts coupled to URL segments and data.
// Configure nested routes with JSX
createBrowserRouter(
  createRoutesFromElements(
    <Route path="/" element={<Root />}>
      <Route path="contact" element={<Contact />} />
      <Route
        path="dashboard"
        element={<Dashboard />}
        loader={({ request }) =>
          fetch("/api/dashboard.json", {
            signal: request.signal,
          })
        }
      />
      <Route element={<AuthLayout />}>
        <Route
          path="login"
          element={<Login />}
          loader={redirectIfUser}
        />
        <Route path="logout" action={logoutUser} />
      </Route>
    </Route>
  )
);

// Or use plain objects
createBrowserRouter([
  {
    path: "/",
    element: <Root />,
    children: [
      {
        path: "contact",
        element: <Contact />,
      },
      {
        path: "dashboard",
        element: <Dashboard />,
        loader: ({ request }) =>
          fetch("/api/dashboard.json", {
            signal: request.signal,
          }),
      },
      {
        element: <AuthLayout />,
        children: [
          {
            path: "login",
            element: <Login />,
            loader: redirectIfUser,
          },
          {
            path: "logout",
            action: logoutUser,
          },
        ],
      },
    ],
  },
]);

This visualization might be helpful.
Dynamic Segments
Segments of the URL can be dynamic placeholders that are parsed and provided to various apis.
<Route path="projects/:projectId/tasks/:taskId" />

The two segments with : are dynamic, and provided to the following APIs:
// If the current location is /projects/abc/tasks/3
<Route
  // sent to loaders
  loader={({ params }) => {
    params.projectId; // abc
    params.taskId; // 3
  }}
  // and actions
  action={({ params }) => {
    params.projectId; // abc
    params.taskId; // 3
  }}
  element={<Task />}
/>;

function Task() {
  // returned from `useParams`
  const params = useParams();
  params.projectId; // abc
  params.taskId; // 3
}

function Random() {
  const match = useMatch(
    "/projects/:projectId/tasks/:taskId"
  );
  match.params.projectId; // abc
  match.params.taskId; // 3
}

See:

<Route path>
<Route loader>
<Route action>
useParams
useMatch

Ranked Route Matching
When matching URLs to routes, React Router will rank the routes according to the number of segments, static segments, dynamic segments, splats, etc. and pick the most specific match.
For example, consider these two routes:
<Route path="/teams/:teamId" />
<Route path="/teams/new" />

Now consider the URL is http://example.com/teams/new.
Even though both routes technically match the URL (new could be the :teamId), you intuitively know that we want the second route (/teams/new) to be picked. React Router's matching algorithm knows that, too.
With ranked routes, you don't have to worry about route ordering.
Active Links
Most web apps have persistent navigation sections at the top of the UI, the sidebar, and often multiple levels. Styling the active navigation items so the user knows where they are (isActive) or where they're going (isPending) in the app is done easily with <NavLink>.
<NavLink
  style={({ isActive, isPending }) => {
    return {
      color: isActive ? "red" : "inherit",
    };
  }}
  className={({ isActive, isPending }) => {
    return isActive ? "active" : isPending ? "pending" : "";
  }}
/>

You can also useMatch for any other "active" indication outside of links.
function SomeComp() {
  const match = useMatch("/messages");
  return <li className={Boolean(match) ? "active" : ""} />;
}

See:

NavLink
useMatch

Relative Links
Like HTML <a href>, <Link to> and <NavLink to> can take relative paths, with enhanced behavior with nested routes.
Given the following route config:
<Route path="home" element={<Home />}>
  <Route path="project/:projectId" element={<Project />}>
    <Route path=":taskId" element={<Task />} />
  </Route>
</Route>

Consider the url https://example.com/home/project/123, which renders the following route component hierarchy:
<Home>
  <Project />
</Home>

If <Project /> renders the following links, the hrefs of the links will resolve like so:



In <Project> @ /home/project/123
Resolved <a href>




<Link to="abc">
/home/project/123/abc


<Link to=".">
/home/project/123


<Link to="..">
/home


<Link to=".." relative="path">
/home/project



Note that the first .. removes both segments of the project/:projectId route. By default, the .. in relative links traverse the route hierarchy, not the URL segments. Adding relative="path" in the next example allows you to traverse the path segments instead.
Relative links are always relative to the route path they are rendered in, not to the full URL. That means if the user navigates deeper with <Link to="abc"> to <Task /> at the URL /home/project/123/abc, the hrefs in <Project> will not change (contrary to plain <a href>, a common problem with client side routers).
Data Loading
Because URL segments usually map to your app's persistent data, React Router provides conventional data loading hooks to initiate data loading during a navigation. Combined with nested routes, all of the data for multiple layouts at a specific URL can be loaded in parallel.
<Route
  path="/"
  loader={async ({ request }) => {
    // loaders can be async functions
    const res = await fetch("/api/user.json", {
      signal: request.signal,
    });
    const user = await res.json();
    return user;
  }}
  element={<Root />}
>
  <Route
    path=":teamId"
    // loaders understand Fetch Responses and will automatically
    // unwrap the res.json(), so you can simply return a fetch
    loader={({ params }) => {
      return fetch(`/api/teams/${params.teamId}`);
    }}
    element={<Team />}
  >
    <Route
      path=":gameId"
      loader={({ params }) => {
        // of course you can use any data store
        return fakeSdk.getTeam(params.gameId);
      }}
      element={<Game />}
    />
  </Route>
</Route>

Data is made available to your components through useLoaderData.
function Root() {
  const user = useLoaderData();
  // data from <Route path="/">
}

function Team() {
  const team = useLoaderData();
  // data from <Route path=":teamId">
}

function Game() {
  const game = useLoaderData();
  // data from <Route path=":gameId">
}

When the user visits or clicks links to https://example.com/real-salt-lake/45face3, all three route loaders will be called and loaded in parallel, before the UI for that URL renders.
Redirects
While loading or changing data, it's common to redirect the user to a different route.
<Route
  path="dashboard"
  loader={async () => {
    const user = await fake.getUser();
    if (!user) {
      // if you know you can't render the route, you can
      // throw a redirect to stop executing code here,
      // sending the user to a new route
      throw redirect("/login");
    }

    // otherwise continue
    const stats = await fake.getDashboardStats();
    return { user, stats };
  }}
/>

<Route
  path="project/new"
  action={async ({ request }) => {
    const data = await request.formData();
    const newProject = await createProject(data);
    // it's common to redirect after actions complete,
    // sending the user to the new record
    return redirect(`/projects/${newProject.id}`);
  }}
/>

See:

redirect
Throwing in Loaders
useNavigate

Pending Navigation UI
When users navigate around the app, the data for the next page is loaded before the page is rendered. It's important to provide user feedback during this time so the app doesn't feel like it's unresponsive.
function Root() {
  const navigation = useNavigation();
  return (
    <div>
      {navigation.state === "loading" && <GlobalSpinner />}
      <FakeSidebar />
      <Outlet />
      <FakeFooter />
    </div>
  );
}

See:

useNavigation

Skeleton UI with <Suspense>
Instead of waiting for the data for the next page, you can defer data so the UI flips over to the next screen with placeholder UI immediately while the data loads.
<Route
  path="issue/:issueId"
  element={<Issue />}
  loader={async ({ params }) => {
    // these are promises, but *not* awaited
    const comments = fake.getIssueComments(params.issueId);
    const history = fake.getIssueHistory(params.issueId);
    // the issue, however, *is* awaited
    const issue = await fake.getIssue(params.issueId);

    // defer enables suspense for the un-awaited promises
    return defer({ issue, comments, history });
  }}
/>;

function Issue() {
  const { issue, history, comments } = useLoaderData();
  return (
    <div>
      <IssueDescription issue={issue} />

      {/* Suspense provides the placeholder fallback */}
      <Suspense fallback={<IssueHistorySkeleton />}>
        {/* Await manages the deferred data (promise) */}
        <Await resolve={history}>
          {/* this calls back when the data is resolved */}
          {(resolvedHistory) => (
            <IssueHistory history={resolvedHistory} />
          )}
        </Await>
      </Suspense>

      <Suspense fallback={<IssueCommentsSkeleton />}>
        <Await resolve={comments}>
          {/* ... or you can use hooks to access the data */}
          <IssueComments />
        </Await>
      </Suspense>
    </div>
  );
}

function IssueComments() {
  const comments = useAsyncValue();
  return <div>{/* ... */}</div>;
}

See

Deferred Data Guide
defer
Await
useAsyncValue

Data Mutations
HTML forms are navigation events, just like links. React Router supports HTML form workflows with client side routing.
When a form is submitted, the normal browser navigation event is prevented and a Request, with a body containing the FormData of the submission, is created. This request is sent to the <Route action> that matches the form's <Form action>.
Form elements's name prop are submitted to the action:
<Form action="/project/new">
  <label>
    Project title
    <br />
    <input type="text" name="title" />
  </label>

  <label>
    Target Finish Date
    <br />
    <input type="date" name="due" />
  </label>
</Form>

The normal HTML document request is prevented and sent to the matching route's action (<Route path> that matches the <form action>), including the request.formData.
<Route
  path="project/new"
  action={async ({ request }) => {
    const formData = await request.formData();
    const newProject = await createProject({
      title: formData.get("title"),
      due: formData.get("due"),
    });
    return redirect(`/projects/${newProject.id}`);
  }}
/>

Data Revalidation
Decades old web conventions indicate that when a form is posted to the server, data is changing and a new page is rendered. That convention is followed in React Router's HTML-based data mutation APIs.
After route actions are called, the loaders for all of the data on the page is called again to ensure the UI stays up-to-date with the data automatically. No cache keys to expire, no context providers to reload.
See:

Tutorial "Creating Contacts"

Busy Indicators
When forms are being submitted to route actions, you have access to the navigation state to display busy indicators, disable fieldsets, etc.
function NewProjectForm() {
  const navigation = useNavigation();
  const busy = navigation.state === "submitting";
  return (
    <Form action="/project/new">
      <fieldset disabled={busy}>
        <label>
          Project title
          <br />
          <input type="text" name="title" />
        </label>

        <label>
          Target Finish Date
          <br />
          <input type="date" name="due" />
        </label>
      </fieldset>
      <button type="submit" disabled={busy}>
        {busy ? "Creating..." : "Create"}
      </button>
    </Form>
  );
}

See:

useNavigation

Optimistic UI
Knowing the formData being sent to an action is often enough to skip the busy indicators and render the UI in the next state immediately, even if your asynchronous work is still pending. This is called "optimistic UI".
function LikeButton({ tweet }) {
  const fetcher = useFetcher();

  // if there is `formData` then it is posting to the action
  const liked = fetcher.formData
    ? // check the formData to be optimistic
      fetcher.formData.get("liked") === "yes"
    : // if its not posting to the action, use the record's value
      tweet.liked;

  return (
    <fetcher.Form method="post" action="toggle-liked">
      <button
        type="submit"
        name="liked"
        value={liked ? "yes" : "no"}
      />
    </fetcher.Form>
  );
}

(Yes, HTML buttons can have a name and a value).
While it is more common to do optimistic UI with a fetcher, you can do the same with a normal form using navigation.formData.
Data Fetchers
HTML Forms are the model for mutations but they have one major limitation: you can have only one at a time because a form submission is a navigation.
Most web apps need to allow for multiple mutations to be happening at the same time, like a list of records where each can be independently deleted, marked complete, liked, etc.
Fetchers allow you to interact with the route actions and loaders without causing a navigation in the browser, but still getting all the conventional benefits like error handling, revalidation, interruption handling, and race condition handling.
Imagine a list of tasks:
function Tasks() {
  const tasks = useLoaderData();
  return tasks.map((task) => (
    <div>
      <p>{task.name}</p>
      <ToggleCompleteButton task={task} />
    </div>
  ));
}

Each task can be marked complete independently of the rest, with its own pending state and without causing a navigation with a fetcher:
function ToggleCompleteButton({ task }) {
  const fetcher = useFetcher();

  return (
    <fetcher.Form method="post" action="/toggle-complete">
      <fieldset disabled={fetcher.state !== "idle"}>
        <input type="hidden" name="id" value={task.id} />
        <input
          type="hidden"
          name="status"
          value={task.complete ? "incomplete" : "complete"}
        />
        <button type="submit">
          {task.status === "complete"
            ? "Mark Incomplete"
            : "Mark Complete"}
        </button>
      </fieldset>
    </fetcher.Form>
  );
}

See:

useFetcher

Race Condition Handling
React Router will cancel stale operations and only commit fresh data automatically.
Any time you have asynchronous UI you have the risk of race conditions: when an async operation starts after but completes before an earlier operation. The result is a user interface that shows the wrong state.
Consider a search field that updates a list as the user types:
?q=ry    |---------------|
                         ^ commit wrong state
?q=ryan     |--------|
                     ^ lose correct state

Even though the query for q?=ryan went out later, it completed earlier. If not handled correctly, the results will briefly be the correct values for ?q=ryan but then flip over the incorrect results for ?q=ry. Throttling and debouncing are not enough (you can still interrupt the requests that get through). You need cancellation.
If you're using React Router's data conventions you avoid this problem completely and automatically.
?q=ry    |-----------X
                     ^ cancel wrong state when
                       correct state completes earlier
?q=ryan     |--------|
                     ^ commit correct state

Not only does React Router handle race conditions for a navigation like this, it also handles it for many other cases like loading results for an autocomplete or performing multiple concurrent mutations with fetcher (and its automatic, concurrent revalidations).
Error Handling
The vast majority of your application errors are handled automatically by React Router. It will catch any errors that are thrown while:

rendering
loading data
updating data

In practice, this is pretty much every error in your app except those thrown in event handlers (<button onClick>) or useEffect. React Router apps tend to have very few of either.
When an error is thrown, instead of rendering the route's element, the errorElement is rendered.
<Route
  path="/"
  loader={() => {
    something.that.throws.an.error();
  }}
  // this will not be rendered
  element={<HappyPath />}
  // but this will instead
  errorElement={<ErrorBoundary />}
/>

If a route doesn't have an errorElement, the error will bubble to the nearest parent route with an errorElement:
<Route
  path="/"
  element={<HappyPath />}
  errorElement={<ErrorBoundary />}
>
  {/* Errors here bubble up to the parent route */}
  <Route path="login" element={<Login />} />
</Route>

See:

<Route errorElement>
useRouteError

Scroll Restoration
React Router will emulate the browser's scroll restoration on navigation, waiting for data to load before scrolling. This ensures the scroll position is restored to the right spot.
You can also customize the behavior by restoring based on something other than locations (like a url pathname) and preventing the scroll from happening on certain links (like tabs in the middle of a page).
See:

<ScrollRestoration>

Web Standard APIs
React Router is built on web standard APIs. Loaders and actions receive standard Web Fetch API Request objects and can return Response objects, too. Cancellation is done with Abort Signals, search params are handled with URLSearchParams, and data mutations are handled with HTML Forms.
When you get better at React Router, you get better at the web platform.
Search Params
TODO:
Location State
TODO:© Remix Software, Inc.•Brand•Docs and examples CC 4.0

Tutorial v6.22.3 | React Router6.22.3Branchesmain (6.22.3)devVersions6.22.3v4/5.xv3.x Light Dark SystemTutorialGetting StartedFeature Overview Tutorial Examples FAQs Main Concepts UpgradingMigrating to RouterProvider Upgrading from v5 Migrating from @reach/router RoutersPicking a Router 🆕createBrowserRouter 🆕createHashRouter 🆕createMemoryRouter 🆕createStaticHandler 🆕createStaticRouter 🆕RouterProvider 🆕StaticRouterProvider 🆕Router ComponentsBrowserRouter HashRouter MemoryRouter NativeRouter Router StaticRouter RouteRoute 🆕action 🆕errorElement 🆕hydrateFallbackElement 🆕lazy 🆕loader 🆕shouldRevalidate 🆕ComponentsAwait 🆕Form 🆕Link Link (RN) NavLink Navigate Outlet Route Routes ScrollRestoration 🆕HooksuseActionData 🆕useAsyncError 🆕useAsyncValue 🆕useBeforeUnload 🆕useBlocker useFetcher 🆕useFetchers 🆕useFormAction 🆕useHref useInRouterContext useLinkClickHandler useLinkPressHandler useLoaderData 🆕useLocation useMatch useMatches 🆕useNavigate useNavigation 🆕useNavigationType useOutlet useOutletContext useParams unstable_usePrompt useResolvedPath useRevalidator 🆕useRouteError 🆕useRouteLoaderData 🆕useRoutes useSearchParams useSearchParams (RN) useSubmit 🆕unstable_useViewTransitionState Fetch Utilitiesjson 🆕redirect 🆕redirectDocument 🆕UtilitiescreateRoutesFromChildren createRoutesFromElements createSearchParams defer 🆕generatePath isRouteErrorResponse 🆕Location matchPath matchRoutes renderMatches resolvePath GuidesServer-Side Rendering Contributing API Development Strategy 🆕Data Library Integration Deferred Data 🆕Working With FormData 🆕Index Query Param 🆕Getting StartedFeature Overview Tutorial Examples FAQs Main Concepts UpgradingMigrating to RouterProvider Upgrading from v5 Migrating from @reach/router RoutersPicking a Router 🆕createBrowserRouter 🆕createHashRouter 🆕createMemoryRouter 🆕createStaticHandler 🆕createStaticRouter 🆕RouterProvider 🆕StaticRouterProvider 🆕Router ComponentsBrowserRouter HashRouter MemoryRouter NativeRouter Router StaticRouter RouteRoute 🆕action 🆕errorElement 🆕hydrateFallbackElement 🆕lazy 🆕loader 🆕shouldRevalidate 🆕ComponentsAwait 🆕Form 🆕Link Link (RN) NavLink Navigate Outlet Route Routes ScrollRestoration 🆕HooksuseActionData 🆕useAsyncError 🆕useAsyncValue 🆕useBeforeUnload 🆕useBlocker useFetcher 🆕useFetchers 🆕useFormAction 🆕useHref useInRouterContext useLinkClickHandler useLinkPressHandler useLoaderData 🆕useLocation useMatch useMatches 🆕useNavigate useNavigation 🆕useNavigationType useOutlet useOutletContext useParams unstable_usePrompt useResolvedPath useRevalidator 🆕useRouteError 🆕useRouteLoaderData 🆕useRoutes useSearchParams useSearchParams (RN) useSubmit 🆕unstable_useViewTransitionState Fetch Utilitiesjson 🆕redirect 🆕redirectDocument 🆕UtilitiescreateRoutesFromChildren createRoutesFromElements createSearchParams defer 🆕generatePath isRouteErrorResponse 🆕Location matchPath matchRoutes renderMatches resolvePath GuidesServer-Side Rendering Contributing API Development Strategy 🆕Data Library Integration Deferred Data 🆕Working With FormData 🆕Index Query Param 🆕On this pageSetupAdding a RouterThe Root RouteHandling Not Found ErrorsThe Contact Route UINested RoutesClient Side RoutingLoading DataData Writes + HTML FormsCreating ContactsURL Params in LoadersUpdating DataUpdating Contacts with FormDataMutation DiscussionRedirecting new records to the edit pageActive Link StylingGlobal Pending UIDeleting RecordsContextual ErrorsIndex RoutesCancel ButtonURL Search Params and GET SubmissionsGET Submissions with Client Side RoutingSynchronizing URLs to Form StateSubmitting Forms onChangeAdding Search SpinnerManaging the History StackMutations Without NavigationOptimistic UINot Found DataPathless RoutesJSX RoutesOn this pageSetupAdding a RouterThe Root RouteHandling Not Found ErrorsThe Contact Route UINested RoutesClient Side RoutingLoading DataData Writes + HTML FormsCreating ContactsURL Params in LoadersUpdating DataUpdating Contacts with FormDataMutation DiscussionRedirecting new records to the edit pageActive Link StylingGlobal Pending UIDeleting RecordsContextual ErrorsIndex RoutesCancel ButtonURL Search Params and GET SubmissionsGET Submissions with Client Side RoutingSynchronizing URLs to Form StateSubmitting Forms onChangeAdding Search SpinnerManaging the History StackMutations Without NavigationOptimistic UINot Found DataPathless RoutesJSX RoutesTutorial
Welcome to the tutorial! We'll be building a small, but feature-rich app that lets you keep track of your contacts. We expect it to take between 30-60m if you're following along.

👉 Every time you see this it means you need to do something in the app!
The rest is just there for your information and deeper understanding. Let's get to it.
Setup
If you're not going to follow along in your own app, you can skip this section
We'll be using Vite for our bundler and dev server for this tutorial. You'll need Node.js installed for the npm command line tool.
👉️ Open up your terminal and bootstrap a new React app with Vite:
npm create vite@latest name-of-your-project -- --template react
# follow prompts
cd <your new project directory>
npm install react-router-dom localforage match-sorter sort-by
npm run dev

You should be able to visit the URL printed in the terminal:
 VITE v3.0.7  ready in 175 ms

  ➜  Local:   http://127.0.0.1:5173/
  ➜  Network: use --host to expose

We've got some pre-written CSS for this tutorial so we can stay focused on React Router. Feel free to judge it harshly or write your own 😅 (We did things we normally wouldn't in CSS so that the markup in this tutorial could stay as minimal as possible.)
👉 Copy/Paste the tutorial CSS found here into src/index.css
This tutorial will be creating, reading, searching, updating, and deleting data. A typical web app would probably be talking to an API on your web server, but we're going to use browser storage and fake some network latency to keep this focused. None of this code is relevant to React Router, so just go ahead and copy/paste it all.
👉 Copy/Paste the tutorial data module found here into src/contacts.js
All you need in the src folder are contacts.js, main.jsx, and index.css. You can delete anything else (like App.js and assets, etc.).
👉 Delete unused files in src/ so all you have left are these:
src
├── contacts.js
├── index.css
└── main.jsx

If your app is running, it might blow up momentarily, just keep going 😋. And with that, we're ready to get started!
Adding a Router
First thing to do is create a Browser Router and configure our first route. This will enable client side routing for our web app.
The main.jsx file is the entry point. Open it up and we'll put React Router on the page.
👉 Create and render a browser router in main.jsx
import * as React from "react";
import * as ReactDOM from "react-dom/client";
import {
  createBrowserRouter,
  RouterProvider,
} from "react-router-dom";
import "./index.css";

const router = createBrowserRouter([
  {
    path: "/",
    element: <div>Hello world!</div>,
  },
]);

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <RouterProvider router={router} />
  </React.StrictMode>
);

This first route is what we often call the "root route" since the rest of our routes will render inside of it. It will serve as the root layout of the UI, we'll have nested layouts as we get farther along.
The Root Route
Let's add the global layout for this app.
👉 Create src/routes and src/routes/root.jsx
mkdir src/routes
touch src/routes/root.jsx

(If you don't want to be a command line nerd, use your editor instead of those commands 🤓)
👉 Create the root layout component
export default function Root() {
  return (
    <>
      <div id="sidebar">
        <h1>React Router Contacts</h1>
        <div>
          <form id="search-form" role="search">
            <input
              id="q"
              aria-label="Search contacts"
              placeholder="Search"
              type="search"
              name="q"
            />
            <div
              id="search-spinner"
              aria-hidden
              hidden={true}
            />
            <div
              className="sr-only"
              aria-live="polite"
            ></div>
          </form>
          <form method="post">
            <button type="submit">New</button>
          </form>
        </div>
        <nav>
          <ul>
            <li>
              <a href={`/contacts/1`}>Your Name</a>
            </li>
            <li>
              <a href={`/contacts/2`}>Your Friend</a>
            </li>
          </ul>
        </nav>
      </div>
      <div id="detail"></div>
    </>
  );
}

Nothing React Router specific yet, so feel free to copy/paste all of that.
👉 Set <Root> as the root route's element
/* existing imports */
import Root from "./routes/root";

const router = createBrowserRouter([
  {
    path: "/",
    element: <Root />,
  },
]);

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <RouterProvider router={router} />
  </React.StrictMode>
);

The app should look something like this now. It sure is nice having a designer who can also write the CSS, isn't it? (Thank you Jim 🙏).

Handling Not Found Errors
It's always a good idea to know how your app responds to errors early in the project because we all write far more bugs than features when building a new app! Not only will your users get a good experience when this happens, but it helps you during development as well.
We added some links to this app, let's see what happens when we click them?
👉 Click one of the sidebar names

Gross! This is the default error screen in React Router, made worse by our flex box styles on the root element in this app 😂.
Anytime your app throws an error while rendering, loading data, or performing data mutations, React Router will catch it and render an error screen. Let's make our own error page.
👉 Create an error page component
touch src/error-page.jsx

import { useRouteError } from "react-router-dom";

export default function ErrorPage() {
  const error = useRouteError();
  console.error(error);

  return (
    <div id="error-page">
      <h1>Oops!</h1>
      <p>Sorry, an unexpected error has occurred.</p>
      <p>
        <i>{error.statusText || error.message}</i>
      </p>
    </div>
  );
}

👉 Set the <ErrorPage> as the errorElement on the root route
/* previous imports */
import ErrorPage from "./error-page";

const router = createBrowserRouter([
  {
    path: "/",
    element: <Root />,
    errorElement: <ErrorPage />,
  },
]);

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <RouterProvider router={router} />
  </React.StrictMode>
);

The error page should now look like this:

(Well, that's not much better. Maybe somebody forgot to ask the designer to make an error page. Maybe everybody forgets to ask the designer to make an error page and then blames the designer for not thinking of it 😆)
Note that useRouteError provides the error that was thrown. When the user navigates to routes that don't exist you'll get an error response with a "Not Found" statusText. We'll see some other errors later in the tutorial and discuss them more.
For now, it's enough to know that pretty much all of your errors will now be handled by this page instead of infinite spinners, unresponsive pages, or blank screens 🙌
The Contact Route UI
Instead of a 404 "Not Found" page, we want to actually render something at the URLs we've linked to. For that, we need to make a new route.
👉 Create the contact route module
touch src/routes/contact.jsx

👉 Add the contact component UI
It's just a bunch of elements, feel free to copy/paste.
import { Form } from "react-router-dom";

export default function Contact() {
  const contact = {
    first: "Your",
    last: "Name",
    avatar: "https://placekitten.com/g/200/200",
    twitter: "your_handle",
    notes: "Some notes",
    favorite: true,
  };

  return (
    <div id="contact">
      <div>
        <img
          key={contact.avatar}
          src={contact.avatar || null}
        />
      </div>

      <div>
        <h1>
          {contact.first || contact.last ? (
            <>
              {contact.first} {contact.last}
            </>
          ) : (
            <i>No Name</i>
          )}{" "}
          <Favorite contact={contact} />
        </h1>

        {contact.twitter && (
          <p>
            <a
              target="_blank"
              href={`https://twitter.com/${contact.twitter}`}
            >
              {contact.twitter}
            </a>
          </p>
        )}

        {contact.notes && <p>{contact.notes}</p>}

        <div>
          <Form action="edit">
            <button type="submit">Edit</button>
          </Form>
          <Form
            method="post"
            action="destroy"
            onSubmit={(event) => {
              if (
                !confirm(
                  "Please confirm you want to delete this record."
                )
              ) {
                event.preventDefault();
              }
            }}
          >
            <button type="submit">Delete</button>
          </Form>
        </div>
      </div>
    </div>
  );
}

function Favorite({ contact }) {
  // yes, this is a `let` for later
  let favorite = contact.favorite;
  return (
    <Form method="post">
      <button
        name="favorite"
        value={favorite ? "false" : "true"}
        aria-label={
          favorite
            ? "Remove from favorites"
            : "Add to favorites"
        }
      >
        {favorite ? "★" : "☆"}
      </button>
    </Form>
  );
}

Now that we've got a component, let's hook it up to a new route.
👉 Import the contact component and create a new route
/* existing imports */
import Contact from "./routes/contact";

const router = createBrowserRouter([
  {
    path: "/",
    element: <Root />,
    errorElement: <ErrorPage />,
  },
  {
    path: "contacts/:contactId",
    element: <Contact />,
  },
]);

/* existing code */

Now if we click one of the links or visit /contacts/1 we get our new component!

However, it's not inside of our root layout 😠
Nested Routes
We want the contact component to render inside of the <Root> layout like this.

We do it by making the contact route a child of the root route.
👉 Move the contacts route to be a child of the root route
const router = createBrowserRouter([
  {
    path: "/",
    element: <Root />,
    errorElement: <ErrorPage />,
    children: [
      {
        path: "contacts/:contactId",
        element: <Contact />,
      },
    ],
  },
]);

You'll now see the root layout again but a blank page on the right. We need to tell the root route where we want it to render its child routes. We do that with <Outlet>.
Find the <div id="detail"> and put an outlet inside
👉 Render an <Outlet>
import { Outlet } from "react-router-dom";

export default function Root() {
  return (
    <>
      {/* all the other elements */}
      <div id="detail">
        <Outlet />
      </div>
    </>
  );
}

Client Side Routing
You may or may not have noticed, but when we click the links in the sidebar, the browser is doing a full document request for the next URL instead of using React Router.
Client side routing allows our app to update the URL without requesting another document from the server. Instead, the app can immediately render new UI. Let's make it happen with <Link>.
👉 Change the sidebar <a href> to <Link to>
import { Outlet, Link } from "react-router-dom";

export default function Root() {
  return (
    <>
      <div id="sidebar">
        {/* other elements */}

        <nav>
          <ul>
            <li>
              <Link to={`contacts/1`}>Your Name</Link>
            </li>
            <li>
              <Link to={`contacts/2`}>Your Friend</Link>
            </li>
          </ul>
        </nav>

        {/* other elements */}
      </div>
    </>
  );
}

You can open the network tab in the browser devtools to see that it's not requesting documents anymore.
Loading Data
URL segments, layouts, and data are more often than not coupled (tripled?) together. We can see it in this app already:



URL Segment
Component
Data




/
<Root>
list of contacts


contacts/:id
<Contact>
individual contact



Because of this natural coupling, React Router has data conventions to get data into your route components easily.
There are two APIs we'll be using to load data, loader and useLoaderData. First we'll create and export a loader function in the root module, then we'll hook it up to the route. Finally, we'll access and render the data.
👉 Export a loader from root.jsx
import { Outlet, Link } from "react-router-dom";
import { getContacts } from "../contacts";

export async function loader() {
  const contacts = await getContacts();
  return { contacts };
}

👉 Configure the loader on the route
/* other imports */
import Root, { loader as rootLoader } from "./routes/root";

const router = createBrowserRouter([
  {
    path: "/",
    element: <Root />,
    errorElement: <ErrorPage />,
    loader: rootLoader,
    children: [
      {
        path: "contacts/:contactId",
        element: <Contact />,
      },
    ],
  },
]);

👉 Access and render the data
import {
  Outlet,
  Link,
  useLoaderData,
} from "react-router-dom";
import { getContacts } from "../contacts";

/* other code */

export default function Root() {
  const { contacts } = useLoaderData();
  return (
    <>
      <div id="sidebar">
        <h1>React Router Contacts</h1>
        {/* other code */}

        <nav>
          {contacts.length ? (
            <ul>
              {contacts.map((contact) => (
                <li key={contact.id}>
                  <Link to={`contacts/${contact.id}`}>
                    {contact.first || contact.last ? (
                      <>
                        {contact.first} {contact.last}
                      </>
                    ) : (
                      <i>No Name</i>
                    )}{" "}
                    {contact.favorite && <span>★</span>}
                  </Link>
                </li>
              ))}
            </ul>
          ) : (
            <p>
              <i>No contacts</i>
            </p>
          )}
        </nav>

        {/* other code */}
      </div>
    </>
  );
}

That's it! React Router will now automatically keep that data in sync with your UI. We don't have any data yet, so you're probably getting a blank list like this:

Data Writes + HTML Forms
We'll create our first contact in a second, but first let's talk about HTML.
React Router emulates HTML Form navigation as the data mutation primitive, according to web development before the JavaScript cambrian explosion. It gives you the UX capabilities of client rendered apps with the simplicity of the "old school" web model.
While unfamiliar to some web developers, HTML forms actually cause a navigation in the browser, just like clicking a link. The only difference is in the request: links can only change the URL while forms can also change the request method (GET vs POST) and the request body (POST form data).
Without client side routing, the browser will serialize the form's data automatically and send it to the server as the request body for POST, and as URLSearchParams for GET. React Router does the same thing, except instead of sending the request to the server, it uses client side routing and sends it to a route action.
We can test this out by clicking the "New" button in our app. The app should blow up because the Vite server isn't configured to handle a POST request (it sends a 404, though it should probably be a 405 🤷).

Instead of sending that POST to the Vite server to create a new contact, let's use client side routing instead.
Creating Contacts
We'll create new contacts by exporting an action in our root route, wiring it up to the route config, and changing our <form> to a React Router <Form>.
👉 Create the action and change <form> to <Form>
import {
  Outlet,
  Link,
  useLoaderData,
  Form,
} from "react-router-dom";
import { getContacts, createContact } from "../contacts";

export async function action() {
  const contact = await createContact();
  return { contact };
}

/* other code */

export default function Root() {
  const { contacts } = useLoaderData();
  return (
    <>
      <div id="sidebar">
        <h1>React Router Contacts</h1>
        <div>
          {/* other code */}
          <Form method="post">
            <button type="submit">New</button>
          </Form>
        </div>

        {/* other code */}
      </div>
    </>
  );
}

👉 Import and set the action on the route
/* other imports */

import Root, {
  loader as rootLoader,
  action as rootAction,
} from "./routes/root";

const router = createBrowserRouter([
  {
    path: "/",
    element: <Root />,
    errorElement: <ErrorPage />,
    loader: rootLoader,
    action: rootAction,
    children: [
      {
        path: "contacts/:contactId",
        element: <Contact />,
      },
    ],
  },
]);

That's it! Go ahead and click the "New" button and you should see a new record pop into the list 🥳

The createContact method just creates an empty contact with no name or data or anything. But it does still create a record, promise!

🧐 Wait a sec ... How did the sidebar update? Where did we call the action? Where's the code to refetch the data? Where are useState, onSubmit and useEffect?!

This is where the "old school web" programming model shows up. As we discussed earlier, <Form> prevents the browser from sending the request to the server and sends it to your route action instead. In web semantics, a POST usually means some data is changing. By convention, React Router uses this as a hint to automatically revalidate the data on the page after the action finishes. That means all of your useLoaderData hooks update and the UI stays in sync with your data automatically! Pretty cool.
URL Params in Loaders
👉 Click on the No Name record
We should be seeing our old static contact page again, with one difference: the URL now has a real ID for the record.

Reviewing the route config, the route looks like this:
[
  {
    path: "contacts/:contactId",
    element: <Contact />,
  },
];

Note the :contactId URL segment. The colon (:) has special meaning, turning it into a "dynamic segment". Dynamic segments will match dynamic (changing) values in that position of the URL, like the contact ID. We call these values in the URL "URL Params", or just "params" for short.
These params are passed to the loader with keys that match the dynamic segment. For example, our segment is named :contactId so the value will be passed as params.contactId.
These params are most often used to find a record by ID. Let's try it out.
👉 Add a loader to the contact page and access data with useLoaderData
import { Form, useLoaderData } from "react-router-dom";
import { getContact } from "../contacts";

export async function loader({ params }) {
  const contact = await getContact(params.contactId);
  return { contact };
}

export default function Contact() {
  const { contact } = useLoaderData();
  // existing code
}

👉 Configure the loader on the route
/* existing code */
import Contact, {
  loader as contactLoader,
} from "./routes/contact";

const router = createBrowserRouter([
  {
    path: "/",
    element: <Root />,
    errorElement: <ErrorPage />,
    loader: rootLoader,
    action: rootAction,
    children: [
      {
        path: "contacts/:contactId",
        element: <Contact />,
        loader: contactLoader,
      },
    ],
  },
]);

/* existing code */


Updating Data
Just like creating data, you update data with <Form>. Let's make a new route at contacts/:contactId/edit. Again, we'll start with the component and then wire it up to the route config.
👉 Create the edit component
touch src/routes/edit.jsx

👉 Add the edit page UI
Nothing we haven't seen before, feel free to copy/paste:
import { Form, useLoaderData } from "react-router-dom";

export default function EditContact() {
  const { contact } = useLoaderData();

  return (
    <Form method="post" id="contact-form">
      <p>
        <span>Name</span>
        <input
          placeholder="First"
          aria-label="First name"
          type="text"
          name="first"
          defaultValue={contact.first}
        />
        <input
          placeholder="Last"
          aria-label="Last name"
          type="text"
          name="last"
          defaultValue={contact.last}
        />
      </p>
      <label>
        <span>Twitter</span>
        <input
          type="text"
          name="twitter"
          placeholder="@jack"
          defaultValue={contact.twitter}
        />
      </label>
      <label>
        <span>Avatar URL</span>
        <input
          placeholder="https://example.com/avatar.jpg"
          aria-label="Avatar URL"
          type="text"
          name="avatar"
          defaultValue={contact.avatar}
        />
      </label>
      <label>
        <span>Notes</span>
        <textarea
          name="notes"
          defaultValue={contact.notes}
          rows={6}
        />
      </label>
      <p>
        <button type="submit">Save</button>
        <button type="button">Cancel</button>
      </p>
    </Form>
  );
}

👉 Add the new edit route
/* existing code */
import EditContact from "./routes/edit";

const router = createBrowserRouter([
  {
    path: "/",
    element: <Root />,
    errorElement: <ErrorPage />,
    loader: rootLoader,
    action: rootAction,
    children: [
      {
        path: "contacts/:contactId",
        element: <Contact />,
        loader: contactLoader,
      },
      {
        path: "contacts/:contactId/edit",
        element: <EditContact />,
        loader: contactLoader,
      },
    ],
  },
]);

/* existing code */

We want it to be rendered in the root route's outlet, so we made it a sibling to the existing child route.
(You might note we reused the contactLoader for this route. This is only because we're being lazy in the tutorial. There is no reason to attempt to share loaders among routes, they usually have their own.)
Alright, clicking the "Edit" button gives us this new UI:

Updating Contacts with FormData
The edit route we just created already renders a form. All we need to do to update the record is wire up an action to the route. The form will post to the action and the data will be automatically revalidated.
👉 Add an action to the edit module
import {
  Form,
  useLoaderData,
  redirect,
} from "react-router-dom";
import { updateContact } from "../contacts";

export async function action({ request, params }) {
  const formData = await request.formData();
  const updates = Object.fromEntries(formData);
  await updateContact(params.contactId, updates);
  return redirect(`/contacts/${params.contactId}`);
}

/* existing code */

👉 Wire the action up to the route
/* existing code */
import EditContact, {
  action as editAction,
} from "./routes/edit";

const router = createBrowserRouter([
  {
    path: "/",
    element: <Root />,
    errorElement: <ErrorPage />,
    loader: rootLoader,
    action: rootAction,
    children: [
      {
        path: "contacts/:contactId",
        element: <Contact />,
        loader: contactLoader,
      },
      {
        path: "contacts/:contactId/edit",
        element: <EditContact />,
        loader: contactLoader,
        action: editAction,
      },
    ],
  },
]);

/* existing code */

Fill out the form, hit save, and you should see something like this! (Except easier on the eyes and maybe less hairy.)

Mutation Discussion

😑 It worked, but I have no idea what is going on here...

Let's dig in a bit...
Open up src/routes/edit.jsx and look at the form elements. Notice how they each have a name:
<input
  placeholder="First"
  aria-label="First name"
  type="text"
  name="first"
  defaultValue={contact.first}
/>

Without JavaScript, when a form is submitted, the browser will create FormData and set it as the body of the request when it sends it to the server. As mentioned before, React Router prevents that and sends the request to your action instead, including the FormData.
Each field in the form is accessible with formData.get(name). For example, given the input field from above, you could access the first and last names like this:
export async function action({ request, params }) {
  const formData = await request.formData();
  const firstName = formData.get("first");
  const lastName = formData.get("last");
  // ...
}

Since we have a handful of form fields, we used Object.fromEntries to collect them all into an object, which is exactly what our updateContact function wants.
const updates = Object.fromEntries(formData);
updates.first; // "Some"
updates.last; // "Name"

Aside from action, none of these APIs we're discussing are provided by React Router: request, request.formData, Object.fromEntries are all provided by the web platform.
After we finished the action, note the redirect at the end:
export async function action({ request, params }) {
  const formData = await request.formData();
  const updates = Object.fromEntries(formData);
  await updateContact(params.contactId, updates);
  return redirect(`/contacts/${params.contactId}`);
}

Loaders and actions can both return a Response (makes sense, since they received a Request!). The redirect helper just makes it easier to return a response that tells the app to change locations.
Without client side routing, if a server redirected after a POST request, the new page would fetch the latest data and render. As we learned before, React Router emulates this model and automatically revalidates the data on the page after the action. That's why the sidebar automatically updates when we save the form. The extra revalidation code doesn't exist without client side routing, so it doesn't need to exist with client side routing either!
Redirecting new records to the edit page
Now that we know how to redirect, let's update the action that creates new contacts to redirect to the edit page:
👉 Redirect to the new record's edit page
import {
  Outlet,
  Link,
  useLoaderData,
  Form,
  redirect,
} from "react-router-dom";
import { getContacts, createContact } from "../contacts";

export async function action() {
  const contact = await createContact();
  return redirect(`/contacts/${contact.id}/edit`);
}

Now when we click "New", we should end up on the edit page:

👉 Add a handful of records
I'm going to use the stellar lineup of speakers from the first Remix Conference 😁

Active Link Styling
Now that we have a bunch of records, it's not clear which one we're looking at in the sidebar. We can use NavLink to fix this.
👉 Use a NavLink in the sidebar
import {
  Outlet,
  NavLink,
  useLoaderData,
  Form,
  redirect,
} from "react-router-dom";

export default function Root() {
  return (
    <>
      <div id="sidebar">
        {/* other code */}

        <nav>
          {contacts.length ? (
            <ul>
              {contacts.map((contact) => (
                <li key={contact.id}>
                  <NavLink
                    to={`contacts/${contact.id}`}
                    className={({ isActive, isPending }) =>
                      isActive
                        ? "active"
                        : isPending
                        ? "pending"
                        : ""
                    }
                  >
                    {/* other code */}
                  </NavLink>
                </li>
              ))}
            </ul>
          ) : (
            <p>{/* other code */}</p>
          )}
        </nav>
      </div>
    </>
  );
}

Note that we are passing a function to className. When the user is at the URL in the NavLink, then isActive will be true. When it's about to be active (the data is still loading) then isPending will be true. This allows us to easily indicate where the user is, as well as provide immediate feedback on links that have been clicked but we're still waiting for data to load.

Global Pending UI
As the user navigates the app, React Router will leave the old page up as data is loading for the next page. You may have noticed the app feels a little unresponsive as you click between the list. Let's provide the user with some feedback so the app doesn't feel unresponsive.
React Router is managing all of the state behind the scenes and reveals the pieces of it you need to build dynamic web apps. In this case, we'll use the useNavigation hook.
👉 useNavigation to add global pending UI
import {
  // existing code
  useNavigation,
} from "react-router-dom";

// existing code

export default function Root() {
  const { contacts } = useLoaderData();
  const navigation = useNavigation();

  return (
    <>
      <div id="sidebar">{/* existing code */}</div>
      <div
        id="detail"
        className={
          navigation.state === "loading" ? "loading" : ""
        }
      >
        <Outlet />
      </div>
    </>
  );
}

useNavigation returns the current navigation state: it can be one of "idle" | "submitting" | "loading".
In our case, we add a "loading" class to the main part of the app if we're not idle. The CSS then adds a nice fade after a short delay (to avoid flickering the UI for fast loads). You could do anything you want though, like show a spinner or loading bar across the top.

Note that our data model (src/contacts.js) has a clientside cache, so navigating to the same contact is fast the second time. This behavior is not React Router, it will re-load data for changing routes no matter if you've been there before or not. It does, however, avoid calling the loaders for unchanging routes (like the list) during a navigation.
Deleting Records
If we review code in the contact route, we can find the delete button looks like this:
<Form
  method="post"
  action="destroy"
  onSubmit={(event) => {
    if (
      !confirm(
        "Please confirm you want to delete this record."
      )
    ) {
      event.preventDefault();
    }
  }}
>
  <button type="submit">Delete</button>
</Form>

Note the action points to "destroy". Like <Link to>, <Form action> can take a relative value. Since the form is rendered in contact/:contactId, then a relative action with destroy will submit the form to contact/:contactId/destroy when clicked.
At this point you should know everything you need to know to make the delete button work. Maybe give it a shot before moving on? You'll need:

A new route
An action at that route
deleteContact from src/contacts.js

👉 Create the "destroy" route module
touch src/routes/destroy.jsx

👉 Add the destroy action
import { redirect } from "react-router-dom";
import { deleteContact } from "../contacts";

export async function action({ params }) {
  await deleteContact(params.contactId);
  return redirect("/");
}

👉 Add the destroy route to the route config
/* existing code */
import { action as destroyAction } from "./routes/destroy";

const router = createBrowserRouter([
  {
    path: "/",
    /* existing root route props */
    children: [
      /* existing routes */
      {
        path: "contacts/:contactId/destroy",
        action: destroyAction,
      },
    ],
  },
]);

/* existing code */

Alright, navigate to a record and click the "Delete" button. It works!

😅 I'm still confused why this all works

When the user clicks the submit button:

<Form> prevents the default browser behavior of sending a new POST request to the server, but instead emulates the browser by creating a POST request with client side routing
The <Form action="destroy"> matches the new route at "contacts/:contactId/destroy" and sends it the request
After the action redirects, React Router calls all of the loaders for the data on the page to get the latest values (this is "revalidation"). useLoaderData returns new values and causes the components to update!

Add a form, add an action, React Router does the rest.
Contextual Errors
Just for kicks, throw an error in the destroy action:
export async function action({ params }) {
  throw new Error("oh dang!");
  await deleteContact(params.contactId);
  return redirect("/");
}


Recognize that screen? It's our errorElement from before. The user, however, can't really do anything to recover from this screen except to hit refresh.
Let's create a contextual error message for the destroy route:
[
  /* other routes */
  {
    path: "contacts/:contactId/destroy",
    action: destroyAction,
    errorElement: <div>Oops! There was an error.</div>,
  },
];

Now try it again:

Our user now has more options than slamming refresh, they can continue to interact with the parts of the page that aren't having trouble 🙌
Because the destroy route has its own errorElement and is a child of the root route, the error will render there instead of the root. As you probably noticed, these errors bubble up to the nearest errorElement. Add as many or as few as you like, as long as you've got one at the root.
Index Routes
When we load up the app, you'll notice a big blank page on the right side of our list.

When a route has children, and you're at the parent route's path, the <Outlet> has nothing to render because no children match. You can think of index routes as the default child route to fill in that space.
👉 Create the index route module
touch src/routes/index.jsx

👉 Fill in the index component's elements
Feel free to copy paste, nothing special here.
export default function Index() {
  return (
    <p id="zero-state">
      This is a demo for React Router.
      <br />
      Check out{" "}
      <a href="https://reactrouter.com">
        the docs at reactrouter.com
      </a>
      .
    </p>
  );
}

👉 Configure the index route
// existing code
import Index from "./routes/index";

const router = createBrowserRouter([
  {
    path: "/",
    element: <Root />,
    errorElement: <ErrorPage />,
    loader: rootLoader,
    action: rootAction,
    children: [
      { index: true, element: <Index /> },
      /* existing routes */
    ],
  },
]);

Note the { index:true } instead of { path: "" }. That tells the router to match and render this route when the user is at the parent route's exact path, so there are no other child routes to render in the <Outlet>.

Voila! No more blank space. It's common to put dashboards, stats, feeds, etc. at index routes. They can participate in data loading as well.
Cancel Button
On the edit page we've got a cancel button that doesn't do anything yet. We'd like it to do the same thing as the browser's back button.
We'll need a click handler on the button as well as useNavigate from React Router.
👉 Add the cancel button click handler with useNavigate
import {
  Form,
  useLoaderData,
  redirect,
  useNavigate,
} from "react-router-dom";

export default function EditContact() {
  const { contact } = useLoaderData();
  const navigate = useNavigate();

  return (
    <Form method="post" id="contact-form">
      {/* existing code */}

      <p>
        <button type="submit">Save</button>
        <button
          type="button"
          onClick={() => {
            navigate(-1);
          }}
        >
          Cancel
        </button>
      </p>
    </Form>
  );
}

Now when the user clicks "Cancel", they'll be sent back one entry in the browser's history.

🧐 Why is there no event.preventDefault on the button?

A <button type="button">, while seemingly redundant, is the HTML way of preventing a button from submitting its form.
Two more features to go. We're on the home stretch!
URL Search Params and GET Submissions
All of our interactive UI so far have been either links that change the URL or forms that post data to actions. The search field is interesting because it's a mix of both: it's a form but it only changes the URL, it doesn't change data.
Right now it's just a normal HTML <form>, not a React Router <Form>. Let's see what the browser does with it by default:
👉 Type a name into the search field and hit the enter key
Note the browser's URL now contains your query in the URL as URLSearchParams:
http://127.0.0.1:5173/?q=ryan

If we review the search form, it looks like this:
<form id="search-form" role="search">
  <input
    id="q"
    aria-label="Search contacts"
    placeholder="Search"
    type="search"
    name="q"
  />
  <div id="search-spinner" aria-hidden hidden={true} />
  <div className="sr-only" aria-live="polite"></div>
</form>

As we've seen before, browsers can serialize forms by the name attribute of it's input elements. The name of this input is q, that's why the URL has ?q=. If we named it search the URL would be ?search=.
Note that this form is different from the others we've used, it does not have <form method="post">. The default method is "get". That means when the browser creates the request for the next document, it doesn't put the form data into the request POST body, but into the URLSearchParams of a GET request.
GET Submissions with Client Side Routing
Let's use client side routing to submit this form and filter the list in our existing loader.
👉 Change <form> to <Form>
<Form id="search-form" role="search">
  <input
    id="q"
    aria-label="Search contacts"
    placeholder="Search"
    type="search"
    name="q"
  />
  <div id="search-spinner" aria-hidden hidden={true} />
  <div className="sr-only" aria-live="polite"></div>
</Form>

👉 Filter the list if there are URLSearchParams
export async function loader({ request }) {
  const url = new URL(request.url);
  const q = url.searchParams.get("q");
  const contacts = await getContacts(q);
  return { contacts };
}


Because this is a GET, not a POST, React Router does not call the action. Submitting a GET form is the same as clicking a link: only the URL changes. That's why the code we added for filtering is in the loader, not the action of this route.
This also means it's a normal page navigation. You can click the back button to get back to where you were.
Synchronizing URLs to Form State
There are a couple of UX issues here that we can take care of quickly.

If you click back after a search, the form field still has the value you entered even though the list is no longer filtered.
If you refresh the page after searching, the form field no longer has the value in it, even though the list is filtered

In other words, the URL and our form state are out of sync.
👉 Return q from your loader and set it as the search field default value
// existing code

export async function loader({ request }) {
  const url = new URL(request.url);
  const q = url.searchParams.get("q");
  const contacts = await getContacts(q);
  return { contacts, q };
}

export default function Root() {
  const { contacts, q } = useLoaderData();
  const navigation = useNavigation();

  return (
    <>
      <div id="sidebar">
        <h1>React Router Contacts</h1>
        <div>
          <Form id="search-form" role="search">
            <input
              id="q"
              aria-label="Search contacts"
              placeholder="Search"
              type="search"
              name="q"
              defaultValue={q}
            />
            {/* existing code */}
          </Form>
          {/* existing code */}
        </div>
        {/* existing code */}
      </div>
      {/* existing code */}
    </>
  );
}

That solves problem (2). If you refresh the page now, the input field will show the query.

Now for problem (1), clicking the back button and updating the input. We can bring in useEffect from React to manipulate the form's state in the DOM directly.
👉 Synchronize input value with the URL Search Params
import { useEffect } from "react";

// existing code

export default function Root() {
  const { contacts, q } = useLoaderData();
  const navigation = useNavigation();

  useEffect(() => {
    document.getElementById("q").value = q;
  }, [q]);

  // existing code
}


🤔 Shouldn't you use a controlled component and React State for this?

You could certainly do this as a controlled component, but you'll end up with more complexity for the same behavior. You don't control the URL, the user does with the back/forward buttons. There would be more synchronization points with a controlled component.

If you're still concerned, expand this to see what it would look like
Notice how controlling the input requires three points of synchronization now instead of just one. The behavior is identical but the code is more complex.
import { useEffect, useState } from "react";
// existing code

export async function loader({ request }) {
  const url = new URL(request.url);
  const q = url.searchParams.get("q") || "";
  const contacts = await getContacts(q);
  return { contacts, q };
}

// existing code

export default function Root() {
  const { contacts, q } = useLoaderData();
  const [query, setQuery] = useState(q);
  const navigation = useNavigation();

  useEffect(() => {
    setQuery(q);
  }, [q]);

  return (
    <>
      <div id="sidebar">
        <h1>React Router Contacts</h1>
        <div>
          <Form id="search-form" role="search">
            <input
              id="q"
              aria-label="Search contacts"
              placeholder="Search"
              type="search"
              name="q"
              value={query}
              onChange={(e) => {
                setQuery(e.target.value);
              }}
            />
            {/* existing code */}
          </Form>
          {/* existing code */}
        </div>
        {/* existing code */}
      </div>
    </>
  );
}


Submitting Forms onChange
We've got a product decision to make here. For this UI, we'd probably rather have the filtering happen on every key stroke instead of when the form is explicitly submitted.
We've seen useNavigate already, we'll use its cousin, useSubmit, for this.
// existing code
import {
  // existing code
  useSubmit,
} from "react-router-dom";

export default function Root() {
  const { contacts, q } = useLoaderData();
  const navigation = useNavigation();
  const submit = useSubmit();

  return (
    <>
      <div id="sidebar">
        <h1>React Router Contacts</h1>
        <div>
          <Form id="search-form" role="search">
            <input
              id="q"
              aria-label="Search contacts"
              placeholder="Search"
              type="search"
              name="q"
              defaultValue={q}
              onChange={(event) => {
                submit(event.currentTarget.form);
              }}
            />
            {/* existing code */}
          </Form>
          {/* existing code */}
        </div>
        {/* existing code */}
      </div>
      {/* existing code */}
    </>
  );
}

Now as you type, the form is submitted automatically!
Note the argument to submit. We're passing in event.currentTarget.form. The currentTarget is the DOM node the event is attached to, and the currentTarget.form is the input's parent form node. The submit function will serialize and submit any form you pass to it.
Adding Search Spinner
In a production app, it's likely this search will be looking for records in a database that is too large to send all at once and filter client side. That's why this demo has some faked network latency.
Without any loading indicator, the search feels kinda sluggish. Even if we could make our database faster, we'll always have the user's network latency in the way and out of our control. For a better UX, let's add some immediate UI feedback for the search. For this we'll use useNavigation again.
👉 Add the search spinner
// existing code

export default function Root() {
  const { contacts, q } = useLoaderData();
  const navigation = useNavigation();
  const submit = useSubmit();

  const searching =
    navigation.location &&
    new URLSearchParams(navigation.location.search).has(
      "q"
    );

  useEffect(() => {
    document.getElementById("q").value = q;
  }, [q]);

  return (
    <>
      <div id="sidebar">
        <h1>React Router Contacts</h1>
        <div>
          <Form id="search-form" role="search">
            <input
              id="q"
              className={searching ? "loading" : ""}
              // existing code
            />
            <div
              id="search-spinner"
              aria-hidden
              hidden={!searching}
            />
            {/* existing code */}
          </Form>
          {/* existing code */}
        </div>
        {/* existing code */}
      </div>
      {/* existing code */}
    </>
  );
}


The navigation.location will show up when the app is navigating to a new URL and loading the data for it. It then goes away when there is no pending navigation anymore.
Managing the History Stack
Now that the form is submitted for every key stroke, if we type the characters "seba" and then delete them with backspace, we end up with 7 new entries in the stack 😂. We definitely don't want this

We can avoid this by replacing the current entry in the history stack with the next page, instead of pushing into it.
👉 Use replace in submit
// existing code

export default function Root() {
  // existing code

  return (
    <>
      <div id="sidebar">
        <h1>React Router Contacts</h1>
        <div>
          <Form id="search-form" role="search">
            <input
              id="q"
              // existing code
              onChange={(event) => {
                const isFirstSearch = q == null;
                submit(event.currentTarget.form, {
                  replace: !isFirstSearch,
                });
              }}
            />
            {/* existing code */}
          </Form>
          {/* existing code */}
        </div>
        {/* existing code */}
      </div>
      {/* existing code */}
    </>
  );
}

We only want to replace search results, not the page before we started searching, so we do a quick check if this is the first search or not and then decide to replace.
Each key stroke no longer creates new entries, so the user can click back out of the search results without having to click it 7 times 😅.
Mutations Without Navigation
So far all of our mutations (the times we change data) have used forms that navigate, creating new entries in the history stack. While these user flows are common, it's equally as common to want to change data without causing a navigation.
For these cases, we have the useFetcher hook. It allows us to communicate with loaders and actions without causing a navigation.
The ★ button on the contact page makes sense for this. We aren't creating or deleting a new record, we don't want to change pages, we simply want to change the data on the page we're looking at.
👉 Change the <Favorite> form to a fetcher form
import {
  useLoaderData,
  Form,
  useFetcher,
} from "react-router-dom";

// existing code

function Favorite({ contact }) {
  const fetcher = useFetcher();
  let favorite = contact.favorite;

  return (
    <fetcher.Form method="post">
      <button
        name="favorite"
        value={favorite ? "false" : "true"}
        aria-label={
          favorite
            ? "Remove from favorites"
            : "Add to favorites"
        }
      >
        {favorite ? "★" : "☆"}
      </button>
    </fetcher.Form>
  );
}

Might want to take a look at that form while we're here. As always, our form has fields with a name prop. This form will send formData with a favorite key that's either "true" | "false". Since it's got method="post" it will call the action. Since there is no <fetcher.Form action="..."> prop, it will post to the route where the form is rendered.
👉 Create the action
// existing code
import { getContact, updateContact } from "../contacts";

export async function action({ request, params }) {
  let formData = await request.formData();
  return updateContact(params.contactId, {
    favorite: formData.get("favorite") === "true",
  });
}

export default function Contact() {
  // existing code
}

Pretty simple. Pull the form data off the request and send it to the data model.
👉 Configure the route's new action
// existing code
import Contact, {
  loader as contactLoader,
  action as contactAction,
} from "./routes/contact";

const router = createBrowserRouter([
  {
    path: "/",
    element: <Root />,
    errorElement: <ErrorPage />,
    loader: rootLoader,
    action: rootAction,
    children: [
      { index: true, element: <Index /> },
      {
        path: "contacts/:contactId",
        element: <Contact />,
        loader: contactLoader,
        action: contactAction,
      },
      /* existing code */
    ],
  },
]);

Alright, we're ready to click the star next to the user's name!

Check that out, both stars automatically update. Our new <fetcher.Form method="post"> works almost exactly like the <Form> we've been using: it calls the action and then all data is revalidated automatically--even your errors will be caught the same way.
There is one key difference though, it's not a navigation--the URL doesn't change, the history stack is unaffected.
Optimistic UI
You probably noticed the app felt kind of unresponsive when we clicked the favorite button from the last section. Once again, we added some network latency because you're going to have it in the real world!
To give the user some feedback, we could put the star into a loading state with fetcher.state (a lot like navigation.state from before), but we can do something even better this time. We can use a strategy called "optimistic UI"
The fetcher knows the form data being submitted to the action, so it's available to you on fetcher.formData. We'll use that to immediately update the star's state, even though the network hasn't finished. If the update eventually fails, the UI will revert to the real data.
👉 Read the optimistic value from fetcher.formData
// existing code

function Favorite({ contact }) {
  const fetcher = useFetcher();

  let favorite = contact.favorite;
  if (fetcher.formData) {
    favorite = fetcher.formData.get("favorite") === "true";
  }

  return (
    <fetcher.Form method="post">
      <button
        name="favorite"
        value={favorite ? "false" : "true"}
        aria-label={
          favorite
            ? "Remove from favorites"
            : "Add to favorites"
        }
      >
        {favorite ? "★" : "☆"}
      </button>
    </fetcher.Form>
  );
}

If you click the button now you should see the star immediately change to the new state. Instead of always rendering the actual data, we check if the fetcher has any formData being submitted, if so, we'll use that instead. When the action is done, the fetcher.formData will no longer exist and we're back to using the actual data. So even if you write bugs in your optimistic UI code, it'll eventually go back to the correct state 🥹
Not Found Data
What happens if the contact we're trying to load doesn't exist?

Our root errorElement is catching this unexpected error as we try to render a null contact. Nice the error was properly handled, but we can do better!
Whenever you have an expected error case in a loader or action–like the data not existing–you can throw. The call stack will break, React Router will catch it, and the error path is rendered instead. We won't even try to render a null contact.
👉 Throw a 404 response in the loader
export async function loader({ params }) {
  const contact = await getContact(params.contactId);
  if (!contact) {
    throw new Response("", {
      status: 404,
      statusText: "Not Found",
    });
  }
  return { contact };
}


Instead of hitting a render error with Cannot read properties of null, we avoid the component completely and render the error path instead, telling the user something more specific.
This keeps your happy paths, happy. Your route elements don't need to concern themselves with error and loading states.
Pathless Routes
One last thing. The last error page we saw would be better if it rendered inside the root outlet, instead of the whole page. In fact, every error in all of our child routes would be better in the outlet, then the user has more options than hitting refresh.
We'd like it to look like this:

We could add the error element to every one of the child routes but, since it's all the same error page, this isn't recommended.
There's a cleaner way. Routes can be used without a path, which lets them participate in the UI layout without requiring new path segments in the URL. Check it out:
👉 Wrap the child routes in a pathless route
createBrowserRouter([
  {
    path: "/",
    element: <Root />,
    loader: rootLoader,
    action: rootAction,
    errorElement: <ErrorPage />,
    children: [
      {
        errorElement: <ErrorPage />,
        children: [
          { index: true, element: <Index /> },
          {
            path: "contacts/:contactId",
            element: <Contact />,
            loader: contactLoader,
            action: contactAction,
          },
          /* the rest of the routes */
        ],
      },
    ],
  },
]);

When any errors are thrown in the child routes, our new pathless route will catch it and render, preserving the root route's UI!
JSX Routes
And for our final trick, many folks prefer to configure their routes with JSX. You can do that with createRoutesFromElements. There is no functional difference between JSX or objects when configuring your routes, it's simply a stylistic preference.
import {
  createRoutesFromElements,
  createBrowserRouter,
  Route,
} from "react-router-dom";

const router = createBrowserRouter(
  createRoutesFromElements(
    <Route
      path="/"
      element={<Root />}
      loader={rootLoader}
      action={rootAction}
      errorElement={<ErrorPage />}
    >
      <Route errorElement={<ErrorPage />}>
        <Route index element={<Index />} />
        <Route
          path="contacts/:contactId"
          element={<Contact />}
          loader={contactLoader}
          action={contactAction}
        />
        <Route
          path="contacts/:contactId/edit"
          element={<EditContact />}
          loader={contactLoader}
          action={editAction}
        />
        <Route
          path="contacts/:contactId/destroy"
          action={destroyAction}
        />
      </Route>
    </Route>
  )
);


That's it! Thanks for giving React Router a shot. We hope this tutorial gives you a solid start to build great user experiences. There's a lot more you can do with React Router, so make sure to check out all the APIs 😀© Remix Software, Inc.•Brand•Docs and examples CC 4.0

Examples v6.22.3 | React Router6.22.3Branchesmain (6.22.3)devVersions6.22.3v4/5.xv3.x Light Dark SystemExamplesGetting StartedFeature Overview Tutorial Examples FAQs Main Concepts UpgradingMigrating to RouterProvider Upgrading from v5 Migrating from @reach/router RoutersPicking a Router 🆕createBrowserRouter 🆕createHashRouter 🆕createMemoryRouter 🆕createStaticHandler 🆕createStaticRouter 🆕RouterProvider 🆕StaticRouterProvider 🆕Router ComponentsBrowserRouter HashRouter MemoryRouter NativeRouter Router StaticRouter RouteRoute 🆕action 🆕errorElement 🆕hydrateFallbackElement 🆕lazy 🆕loader 🆕shouldRevalidate 🆕ComponentsAwait 🆕Form 🆕Link Link (RN) NavLink Navigate Outlet Route Routes ScrollRestoration 🆕HooksuseActionData 🆕useAsyncError 🆕useAsyncValue 🆕useBeforeUnload 🆕useBlocker useFetcher 🆕useFetchers 🆕useFormAction 🆕useHref useInRouterContext useLinkClickHandler useLinkPressHandler useLoaderData 🆕useLocation useMatch useMatches 🆕useNavigate useNavigation 🆕useNavigationType useOutlet useOutletContext useParams unstable_usePrompt useResolvedPath useRevalidator 🆕useRouteError 🆕useRouteLoaderData 🆕useRoutes useSearchParams useSearchParams (RN) useSubmit 🆕unstable_useViewTransitionState Fetch Utilitiesjson 🆕redirect 🆕redirectDocument 🆕UtilitiescreateRoutesFromChildren createRoutesFromElements createSearchParams defer 🆕generatePath isRouteErrorResponse 🆕Location matchPath matchRoutes renderMatches resolvePath GuidesServer-Side Rendering Contributing API Development Strategy 🆕Data Library Integration Deferred Data 🆕Working With FormData 🆕Index Query Param 🆕Getting StartedFeature Overview Tutorial Examples FAQs Main Concepts UpgradingMigrating to RouterProvider Upgrading from v5 Migrating from @reach/router RoutersPicking a Router 🆕createBrowserRouter 🆕createHashRouter 🆕createMemoryRouter 🆕createStaticHandler 🆕createStaticRouter 🆕RouterProvider 🆕StaticRouterProvider 🆕Router ComponentsBrowserRouter HashRouter MemoryRouter NativeRouter Router StaticRouter RouteRoute 🆕action 🆕errorElement 🆕hydrateFallbackElement 🆕lazy 🆕loader 🆕shouldRevalidate 🆕ComponentsAwait 🆕Form 🆕Link Link (RN) NavLink Navigate Outlet Route Routes ScrollRestoration 🆕HooksuseActionData 🆕useAsyncError 🆕useAsyncValue 🆕useBeforeUnload 🆕useBlocker useFetcher 🆕useFetchers 🆕useFormAction 🆕useHref useInRouterContext useLinkClickHandler useLinkPressHandler useLoaderData 🆕useLocation useMatch useMatches 🆕useNavigate useNavigation 🆕useNavigationType useOutlet useOutletContext useParams unstable_usePrompt useResolvedPath useRevalidator 🆕useRouteError 🆕useRouteLoaderData 🆕useRoutes useSearchParams useSearchParams (RN) useSubmit 🆕unstable_useViewTransitionState Fetch Utilitiesjson 🆕redirect 🆕redirectDocument 🆕UtilitiescreateRoutesFromChildren createRoutesFromElements createSearchParams defer 🆕generatePath isRouteErrorResponse 🆕Location matchPath matchRoutes renderMatches resolvePath GuidesServer-Side Rendering Contributing API Development Strategy 🆕Data Library Integration Deferred Data 🆕Working With FormData 🆕Index Query Param 🆕Examples
You can find many examples, including running version of them on StackBlitz in the GitHub repository:
https://github.com/remix-run/react-router/tree/dev/examples© Remix Software, Inc.•Brand•Docs and examples CC 4.0

FAQs v6.22.3 | React Router6.22.3Branchesmain (6.22.3)devVersions6.22.3v4/5.xv3.x Light Dark SystemFAQsGetting StartedFeature Overview Tutorial Examples FAQs Main Concepts UpgradingMigrating to RouterProvider Upgrading from v5 Migrating from @reach/router RoutersPicking a Router 🆕createBrowserRouter 🆕createHashRouter 🆕createMemoryRouter 🆕createStaticHandler 🆕createStaticRouter 🆕RouterProvider 🆕StaticRouterProvider 🆕Router ComponentsBrowserRouter HashRouter MemoryRouter NativeRouter Router StaticRouter RouteRoute 🆕action 🆕errorElement 🆕hydrateFallbackElement 🆕lazy 🆕loader 🆕shouldRevalidate 🆕ComponentsAwait 🆕Form 🆕Link Link (RN) NavLink Navigate Outlet Route Routes ScrollRestoration 🆕HooksuseActionData 🆕useAsyncError 🆕useAsyncValue 🆕useBeforeUnload 🆕useBlocker useFetcher 🆕useFetchers 🆕useFormAction 🆕useHref useInRouterContext useLinkClickHandler useLinkPressHandler useLoaderData 🆕useLocation useMatch useMatches 🆕useNavigate useNavigation 🆕useNavigationType useOutlet useOutletContext useParams unstable_usePrompt useResolvedPath useRevalidator 🆕useRouteError 🆕useRouteLoaderData 🆕useRoutes useSearchParams useSearchParams (RN) useSubmit 🆕unstable_useViewTransitionState Fetch Utilitiesjson 🆕redirect 🆕redirectDocument 🆕UtilitiescreateRoutesFromChildren createRoutesFromElements createSearchParams defer 🆕generatePath isRouteErrorResponse 🆕Location matchPath matchRoutes renderMatches resolvePath GuidesServer-Side Rendering Contributing API Development Strategy 🆕Data Library Integration Deferred Data 🆕Working With FormData 🆕Index Query Param 🆕Getting StartedFeature Overview Tutorial Examples FAQs Main Concepts UpgradingMigrating to RouterProvider Upgrading from v5 Migrating from @reach/router RoutersPicking a Router 🆕createBrowserRouter 🆕createHashRouter 🆕createMemoryRouter 🆕createStaticHandler 🆕createStaticRouter 🆕RouterProvider 🆕StaticRouterProvider 🆕Router ComponentsBrowserRouter HashRouter MemoryRouter NativeRouter Router StaticRouter RouteRoute 🆕action 🆕errorElement 🆕hydrateFallbackElement 🆕lazy 🆕loader 🆕shouldRevalidate 🆕ComponentsAwait 🆕Form 🆕Link Link (RN) NavLink Navigate Outlet Route Routes ScrollRestoration 🆕HooksuseActionData 🆕useAsyncError 🆕useAsyncValue 🆕useBeforeUnload 🆕useBlocker useFetcher 🆕useFetchers 🆕useFormAction 🆕useHref useInRouterContext useLinkClickHandler useLinkPressHandler useLoaderData 🆕useLocation useMatch useMatches 🆕useNavigate useNavigation 🆕useNavigationType useOutlet useOutletContext useParams unstable_usePrompt useResolvedPath useRevalidator 🆕useRouteError 🆕useRouteLoaderData 🆕useRoutes useSearchParams useSearchParams (RN) useSubmit 🆕unstable_useViewTransitionState Fetch Utilitiesjson 🆕redirect 🆕redirectDocument 🆕UtilitiescreateRoutesFromChildren createRoutesFromElements createSearchParams defer 🆕generatePath isRouteErrorResponse 🆕Location matchPath matchRoutes renderMatches resolvePath GuidesServer-Side Rendering Contributing API Development Strategy 🆕Data Library Integration Deferred Data 🆕Working With FormData 🆕Index Query Param 🆕On this pageWhat happened to withRouter? I need it!Why does <Route> have an element prop instead of render or component?How do I add a No Match (404) Route in react-router v6?<Route> doesn't render? How do I compose?How do I nest routes deep in the tree?What Happened to Regexp Routes Paths?On this pageWhat happened to withRouter? I need it!Why does <Route> have an element prop instead of render or component?How do I add a No Match (404) Route in react-router v6?<Route> doesn't render? How do I compose?How do I nest routes deep in the tree?What Happened to Regexp Routes Paths?FAQs
Here are some questions that people commonly have about React Router v6. You might also find what you're looking for in the examples.
What happened to withRouter? I need it!
This question usually stems from the fact that you're using React class components, which don't support hooks. In React Router v6, we fully embraced hooks and use them to share all the router's internal state. But that doesn't mean you can't use the router. Assuming you can actually use hooks (you're on React 16.8+), you just need a wrapper.
import {
  useLocation,
  useNavigate,
  useParams,
} from "react-router-dom";

function withRouter(Component) {
  function ComponentWithRouterProp(props) {
    let location = useLocation();
    let navigate = useNavigate();
    let params = useParams();
    return (
      <Component
        {...props}
        router={{ location, navigate, params }}
      />
    );
  }

  return ComponentWithRouterProp;
}

Why does <Route> have an element prop instead of render or component?
In React Router v6 we switched from using v5's <Route component> and <Route render> APIs to <Route element>. Why is that?
For starters, we see React itself taking the lead here with the <Suspense fallback={<Spinner />}> API. The fallback prop takes a React element, not a component. This lets you easily pass whatever props you want to your <Spinner> from the component that renders it.
Using elements instead of components means we don't have to provide a passProps-style API, so you can get the props you need to your elements. For example, in a component-based API there is no good way to pass props to the <Profile> element that is rendered when <Route path=":userId" component={Profile} /> matches. Most React libraries who take this approach end up with either an API like <Route component={Profile} passProps={{ animate: true }} /> or use a render prop or higher-order component.
Also, Route's rendering API in v5 was rather large. As we worked on v4/5, the conversation went something like this:
// Ah, this is nice and simple!
<Route path=":userId" component={Profile} />

// But wait, how do I pass custom props to the <Profile> element??
// Hmm, maybe we can use a render prop in those situations?
<Route
  path=":userId"
  render={routeProps => (
    <Profile routeProps={routeProps} animate={true} />
  )}
/>

// Ok, now we have two ways to render something with a route. :/

// But wait, what if we want to render something when a route
// *doesn't* match the URL, like a Not Found page? Maybe we
// can use another render prop with slightly different semantics?
<Route
  path=":userId"
  children={({ match }) => (
    match ? (
      <Profile match={match} animate={true} />
    ) : (
      <NotFound />
    )
  )}
/>

// What if I want to get access to the route match, or I need
// to redirect deeper in the tree?
function DeepComponent(routeStuff) {
  // got routeStuff, phew!
}
export default withRouter(DeepComponent);

// Well hey, now at least we've covered all our use cases!
// ... *facepalm*

At least part of the reason for this API sprawl was that React did not provide any way for us to get the information from the <Route> to your route element, so we had to invent clever ways to get both the route data and your own custom props through to your elements: component, render props, passProps higher-order-components ... until hooks came along!
Now, the conversation above goes like this:
// Ah, nice and simple API. And it's just like the <Suspense> API!
// Nothing more to learn here.
<Route path=":userId" element={<Profile />} />

// But wait, how do I pass custom props to the <Profile>
// element? Oh ya, it's just an element. Easy.
<Route path=":userId" element={<Profile animate={true} />} />

// Ok, but how do I access the router's data, like the URL params
// or the current location?
function Profile({ animate }) {
  let params = useParams();
  let location = useLocation();
}

// But what about components deep in the tree?
function DeepComponent() {
  // oh right, same as anywhere else
  let navigate = useNavigate();
}

// Aaaaaaaaand we're done here.

Another important reason for using the element prop in v6 is that <Route children> is reserved for nesting routes. You can read more about this in the guide about getting started with v6.
How do I add a No Match (404) Route in react-router v6?
In v4 we would have just left the path prop off a route. In v5 we would have wrapped our 404 element in a Route and used path="*". In v6 use path="*" and pass the 404 element into the new element prop instead of wrapping it:
<Route path="*" element={<NoMatch />} />

<Route> doesn't render? How do I compose?
In v5 the <Route> component was just a normal component that was like an if statement that rendered when the URL matched its path. In v6, a <Route> element doesn't actually ever render, it's simply there for configuration.
In v5, since routes were just components, MyRoute will be rendered when the path is "/my-route".
let App = () => (
  <div>
    <MyRoute />
  </div>
);

let MyRoute = ({ element, ...rest }) => {
  return (
    <Route path="/my-route" children={<p>Hello!</p>} />
  );
};

In v6, however, the <Route> is only used for its props, so the following code will never render <p>Hello!</p> because <MyRoute> has no path that <Routes> can see:
let App = () => (
  <Routes>
    <MyRoute />
  </Routes>
);

let MyRoute = () => {
  // won't ever render because the path is down here
  return (
    <Route path="/my-route" children={<p>Hello!</p>} />
  );
};

You can get the same behavior by:

Only rendering <Route> elements inside of <Routes>
Moving the composition into the element prop

let App = () => (
  <div>
    <Routes>
      <Route path="/my-route" element={<MyRoute />} />
    </Routes>
  </div>
);

let MyRoute = () => {
  return <p>Hello!</p>;
};

Having a full nested route config available statically in <Routes> is going to enable a lot of features in v6.x, so we encourage you to put your routes in one top-level config. If you really like the idea of components that match the URL independent of any other components, you can make a component that behaves similarly to the v5 Route with this:
function MatchPath({ path, Comp }) {
  let match = useMatch(path);
  return match ? <Comp {...match} /> : null;
}

// Will match anywhere w/o needing to be in a `<Routes>`
<MatchPath path="/accounts/:id" Comp={Account} />;

How do I nest routes deep in the tree?
In v5 you could render a <Route> or <Switch> anywhere you want. You can keep doing the very same thing, but you need to use <Routes> (<Route> without an 's' will not work). We call these "Descendant <Routes>".
It might have looked like this in v5
// somewhere up the tree
<Switch>
  <Route path="/users" component={Users} />
</Switch>;

// and now deeper in the tree
function Users() {
  return (
    <div>
      <h1>Users</h1>
      <Switch>
        <Route path="/users/account" component={Account} />
      </Switch>
    </div>
  );
}

In v6 it's almost the same:

Note the * in the ancestor routes to get it to match deeper URLs even though it has no direct children
You no longer need to know the entire child route path, you can use a relative route now

// somewhere up the tree
<Routes>
  <Route path="/users/*" element={<Users />} />
</Routes>;

// and now deeper in the tree
function Users() {
  return (
    <div>
      <h1>Users</h1>
      <Routes>
        <Route path="account" element={<Account />} />
      </Routes>
    </div>
  );
}

If you had a "floating route" in v5 (not wrapped in a <Switch>), simply wrap it in a <Routes> instead.
// v5
<Route path="/contact" component={Contact} />

// v6
<Routes>
  <Route path="contact" element={<Contact />} />
</Routes>

What Happened to Regexp Routes Paths?
Regexp route paths were removed for two reasons:


Regular expression paths in routes raised a lot of questions for v6's ranked route matching. How do you rank a regex?


We were able to shed an entire dependency (path-to-regexp) and cut the package weight sent to your user's browser significantly. If it were added back, it would represent 1/3 of React Router's page weight!


After looking at a lot of use cases, we found we can still meet them without direct regexp path support, so we made the tradeoff to significantly decrease the bundle size and avoid the open questions around ranking regexp routes.
The majority of regexp routes were only concerned about one URL segment at a time and doing one of two things:

Matching multiple static values
Validating the param in some way (is a number, not a number, etc.)

Matching generally static values
A very common route we've seen is a regex matching multiple language codes:
function App() {
  return (
    <Switch>
      <Route path={/(en|es|fr)/} component={Lang} />
    </Switch>
  );
}

function Lang({ params }) {
  let lang = params[0];
  let translations = I81n[lang];
  // ...
}

These are all actually just static paths, so in v6 you can make three routes and pass the code directly to the component. If you've got a lot of them, make an array and map it into routes to avoid the repetition.
function App() {
  return (
    <Routes>
      <Route path="en" element={<Lang lang="en" />} />
      <Route path="es" element={<Lang lang="es" />} />
      <Route path="fr" element={<Lang lang="fr" />} />
    </Routes>
  );
}

function Lang({ lang }) {
  let translations = I81n[lang];
  // ...
}

Doing some sort of param validation
Another common case was ensuring that parameters were an integer.
function App() {
  return (
    <Switch>
      <Route path={/users\/(\d+)/} component={User} />
    </Switch>
  );
}

function User({ params }) {
  let id = params[0];
  // ...
}

In this case you have to do a bit of work yourself with the regex inside the matching component:
function App() {
  return (
    <Routes>
      <Route path="/users/:id" element={<ValidateUser />} />
      <Route path="/users/*" element={<NotFound />} />
    </Routes>
  );
}

function ValidateUser() {
  let params = useParams();
  let userId = params.id.match(/\d+/);
  if (!userId) {
    return <NotFound />;
  }
  return <User id={params.userId} />;
}

function User(props) {
  let id = props.id;
  // ...
}

In v5 if the regex didn't match then <Switch> would keep trying to match the next routes:
function App() {
  return (
    <Switch>
      <Route path={/users\/(\d+)/} component={User} />
      <Route path="/users/new" exact component={NewUser} />
      <Route
        path="/users/inactive"
        exact
        component={InactiveUsers}
      />
      <Route path="/users/*" component={NotFound} />
    </Switch>
  );
}

Looking at this example you might be concerned that in the v6 version your other routes won't get rendered at their URLs because the :userId route might match first. But, thanks to route ranking, that is not the case. The "new" and "inactive" routes will rank higher and therefore render at their respective URLs:
function App() {
  return (
    <Routes>
      <Route path="/users/:id" element={<ValidateUser />} />
      <Route path="/users/new" element={<NewUser />} />
      <Route
        path="/users/inactive"
        element={<InactiveUsers />}
      />
    </Routes>
  );
}

In fact, the v5 version has all sorts of problems if your routes aren't ordered just right. V6 completely eliminates this problem.
Remix Users
If you're using Remix, you can send proper 40x responses to the browser by moving this work into your loader. This also decreases the size of the browser bundles sent to the user because loaders only run on the server.
import { useLoaderData } from "remix";

export async function loader({ params }) {
  if (!params.id.match(/\d+/)) {
    throw new Response("", { status: 400 });
  }

  let user = await fakeDb.user.find({
    where: { id: params.id },
  });
  if (!user) {
    throw new Response("", { status: 404 });
  }

  return user;
}

function User() {
  let user = useLoaderData();
  // ...
}

Instead of rendering your component, remix will render the nearest catch boundary instead.© Remix Software, Inc.•Brand•Docs and examples CC 4.0

Main Concepts v6.22.3 | React Router6.22.3Branchesmain (6.22.3)devVersions6.22.3v4/5.xv3.x Light Dark SystemMain ConceptsGetting StartedFeature Overview Tutorial Examples FAQs Main Concepts UpgradingMigrating to RouterProvider Upgrading from v5 Migrating from @reach/router RoutersPicking a Router 🆕createBrowserRouter 🆕createHashRouter 🆕createMemoryRouter 🆕createStaticHandler 🆕createStaticRouter 🆕RouterProvider 🆕StaticRouterProvider 🆕Router ComponentsBrowserRouter HashRouter MemoryRouter NativeRouter Router StaticRouter RouteRoute 🆕action 🆕errorElement 🆕hydrateFallbackElement 🆕lazy 🆕loader 🆕shouldRevalidate 🆕ComponentsAwait 🆕Form 🆕Link Link (RN) NavLink Navigate Outlet Route Routes ScrollRestoration 🆕HooksuseActionData 🆕useAsyncError 🆕useAsyncValue 🆕useBeforeUnload 🆕useBlocker useFetcher 🆕useFetchers 🆕useFormAction 🆕useHref useInRouterContext useLinkClickHandler useLinkPressHandler useLoaderData 🆕useLocation useMatch useMatches 🆕useNavigate useNavigation 🆕useNavigationType useOutlet useOutletContext useParams unstable_usePrompt useResolvedPath useRevalidator 🆕useRouteError 🆕useRouteLoaderData 🆕useRoutes useSearchParams useSearchParams (RN) useSubmit 🆕unstable_useViewTransitionState Fetch Utilitiesjson 🆕redirect 🆕redirectDocument 🆕UtilitiescreateRoutesFromChildren createRoutesFromElements createSearchParams defer 🆕generatePath isRouteErrorResponse 🆕Location matchPath matchRoutes renderMatches resolvePath GuidesServer-Side Rendering Contributing API Development Strategy 🆕Data Library Integration Deferred Data 🆕Working With FormData 🆕Index Query Param 🆕Getting StartedFeature Overview Tutorial Examples FAQs Main Concepts UpgradingMigrating to RouterProvider Upgrading from v5 Migrating from @reach/router RoutersPicking a Router 🆕createBrowserRouter 🆕createHashRouter 🆕createMemoryRouter 🆕createStaticHandler 🆕createStaticRouter 🆕RouterProvider 🆕StaticRouterProvider 🆕Router ComponentsBrowserRouter HashRouter MemoryRouter NativeRouter Router StaticRouter RouteRoute 🆕action 🆕errorElement 🆕hydrateFallbackElement 🆕lazy 🆕loader 🆕shouldRevalidate 🆕ComponentsAwait 🆕Form 🆕Link Link (RN) NavLink Navigate Outlet Route Routes ScrollRestoration 🆕HooksuseActionData 🆕useAsyncError 🆕useAsyncValue 🆕useBeforeUnload 🆕useBlocker useFetcher 🆕useFetchers 🆕useFormAction 🆕useHref useInRouterContext useLinkClickHandler useLinkPressHandler useLoaderData 🆕useLocation useMatch useMatches 🆕useNavigate useNavigation 🆕useNavigationType useOutlet useOutletContext useParams unstable_usePrompt useResolvedPath useRevalidator 🆕useRouteError 🆕useRouteLoaderData 🆕useRoutes useSearchParams useSearchParams (RN) useSubmit 🆕unstable_useViewTransitionState Fetch Utilitiesjson 🆕redirect 🆕redirectDocument 🆕UtilitiescreateRoutesFromChildren createRoutesFromElements createSearchParams defer 🆕generatePath isRouteErrorResponse 🆕Location matchPath matchRoutes renderMatches resolvePath GuidesServer-Side Rendering Contributing API Development Strategy 🆕Data Library Integration Deferred Data 🆕Working With FormData 🆕Index Query Param 🆕On this pageDefinitionsHistory and LocationsHistory ObjectLocationsMatchingDefining RoutesMatch ParamsRanking RoutesPathless RoutesRoute MatchesRenderingOutletsIndex RoutesLayout RoutesNavigatingLinkNavigate FunctionData AccessReviewOn this pageDefinitionsHistory and LocationsHistory ObjectLocationsMatchingDefining RoutesMatch ParamsRanking RoutesPathless RoutesRoute MatchesRenderingOutletsIndex RoutesLayout RoutesNavigatingLinkNavigate FunctionData AccessReviewMain Concepts
This document needs to be updated for 6.4 data APIs
This document is a deep dive into the core concepts behind routing as implemented in React Router. It's pretty long, so if you're looking for a more practical guide check out our quick start tutorial.
You might be wondering what exactly React Router does. How can it help you build your app? What exactly is a router, anyway?
If you've ever had any of these questions, or you'd just like to dig into the fundamental pieces of routing, you're in the right place. This document contains detailed explanations of all the core concepts behind routing as implemented in React Router.
Please don't let this document overwhelm you! For everyday use, React Router is pretty simple. You don't need to go this deep to use it.
React Router isn't just about matching a url to a function or component: it's about building a full user interface that maps to the URL, so it might have more concepts in it than you're used to. We'll go into detail on the three main jobs of React Router:

Subscribing and manipulating the history stack
Matching the URL to your routes
Rendering a nested UI from the route matches

Definitions
But first, some definitions! There are a lot of different ideas around routing from back and front end frameworks. Sometimes a word in one context might have different meaning than another.
Here are some words we use a lot when we talk about React Router. The rest of this guide will go into more detail on each one.


URL - The URL in the address bar. A lot of people use the term "URL" and "route" interchangeably, but this is not a route in React Router, it's just a URL.


Location - This is a React Router specific object that is based on the built-in browser's window.location object. It represents "where the user is at". It's mostly an object representation of the URL but has a bit more to it than that.


Location State - A value that persists with a location that isn't encoded in the URL. Much like hash or search params (data encoded in the URL), but stored invisibly in the browser's memory.


History Stack - As the user navigates, the browser keeps track of each location in a stack. If you click and hold the back button in a browser you can see the browser's history stack right there.


Client Side Routing (CSR) - A plain HTML document can link to other documents and the browser handles the history stack itself. Client Side Routing enables developers to manipulate the browser history stack without making a document request to the server.


History - An object that allows React Router to subscribe to changes in the URL as well as providing APIs to manipulate the browser history stack programmatically.


History Action - One of POP, PUSH, or REPLACE. Users can arrive at a URL for one of these three reasons. A push when a new entry is added to the history stack (typically a link click or the programmer forced a navigation). A replace is similar except it replaces the current entry on the stack instead of pushing a new one. Finally, a pop happens when the user clicks the back or forward buttons in the browser chrome.


Segment - The parts of a URL or path pattern between the / characters. For example, "/users/123" has two segments.


Path Pattern - These look like URLs but can have special characters for matching URLs to routes, like dynamic segments ("/users/:userId") or star segments ("/docs/*"). They aren't URLs, they're patterns that React Router will match.


Dynamic Segment - A segment of a path pattern that is dynamic, meaning it can match any values in the segment. For example the pattern /users/:userId will match URLs like /users/123


URL Params - The parsed values from the URL that matched a dynamic segment.


Router - Stateful, top-level component that makes all the other components and hooks work.


Route Config - A tree of routes objects that will be ranked and matched (with nesting) against the current location to create a branch of route matches.


Route - An object or Route Element typically with a shape of { path, element } or <Route path element>. The path is a path pattern. When the path pattern matches the current URL, the element will be rendered.


Route Element - Or <Route>. This element's props are read to create a route by <Routes>, but otherwise does nothing.


Nested Routes - Because routes can have children and each route defines a portion of the URL through segments, a single URL can match multiple routes in a nested "branch" of the tree. This enables automatic layout nesting through outlet, relative links, and more.


Relative links - Links that don't start with / will inherit the closest route in which they are rendered. This makes it easy to link to deeper URLs without having to know and build up the entire path.


Match - An object that holds information when a route matches the URL, like the url params and pathname that matched.


Matches - An array of routes (or branch of the route config) that matches the current location. This structure enables nested routes.


Parent Route - A route with child routes.


Outlet - A component that renders the next match in a set of matches.


Index Route - A child route with no path that renders in the parent's outlet at the parent's URL.


Layout Route - A parent route without a path, used exclusively for grouping child routes inside a specific layout.


History and Locations
Before React Router can do anything, it has to be able to subscribe to changes in the browser history stack.
Browsers maintain their own history stack as the user navigates around. That's how the back and forward buttons can work. In a traditional website (HTML documents without JavaScript) the browser will make requests to the server every time the user clicks a link, submits a form, or clicks the back and forward buttons.
For example, consider the user:

clicks a link to /dashboard
clicks a link to /accounts
clicks a link to /customers/123
clicks the back button
clicks a link to /dashboard

The history stack will change as follows where bold entries denote the current URL:

/dashboard
/dashboard, /accounts
/dashboard, /accounts, /customers/123
/dashboard, /accounts, /customers/123
/dashboard, /accounts, /dashboard

History Object
With client side routing, developers are able to manipulate the browser history stack programmatically. For example, we can write some code like this to change the URL without the browsers default behavior of making a request to the server:
<a
  href="/contact"
  onClick={(event) => {
    // stop the browser from changing the URL and requesting the new document
    event.preventDefault();
    // push an entry into the browser history stack and change the URL
    window.history.pushState({}, undefined, "/contact");
  }}
/>

For illustration only, don't use window.history.pushState directly in React Router
This code changes the URL but doesn't do anything for the UI. We would need to write some more code that changed some state somewhere to get the UI to change to the contact page. The trouble is, the browser doesn't give us a way to "listen to the URL" and subscribe to changes like this.
Well, that's not totally true. We can listen for changes to the URL via pop events:
window.addEventListener("popstate", () => {
  // URL changed!
});

But that only fires when the user clicks the back or forward buttons. There is no event for when the programmer called window.history.pushState or window.history.replaceState.
That's where a React Router specific history object comes into play. It provides a way to "listen for URL" changes whether the history action is push, pop, or replace.
let history = createBrowserHistory();
history.listen(({ location, action }) => {
  // this is called whenever new locations come in
  // the action is POP, PUSH, or REPLACE
});

Apps don't need to set up their own history objects--that's the job of <Router>. It sets up one of these objects, subscribe to changes in the history stack, and finally updates its state when the URL changes. This causes the app to re-render and the correct UI to display. The only thing it needs to put on state is a location, everything else works from that single object.
Locations
The browser has a location object on window.location. It tells you information about the URL but also has some methods to change it:
window.location.pathname; // /getting-started/concepts/
window.location.hash; // #location
window.location.reload(); // force a refresh w/ the server
// and a lot more

For illustration. You don't typically work with window.location in a React Router app
Instead of using window.location, React Router has the concept of a location that's patterned after window.location but is much simpler. It looks like this:
{
  pathname: "/bbq/pig-pickins",
  search: "?campaign=instagram",
  hash: "#menu",
  state: null,
  key: "aefz24ie"
}

The first three: { pathname, search, hash } are exactly like window.location. If you just add up the three you'll get the URL the user sees in the browser:
location.pathname + location.search + location.hash;
// /bbq/pig-pickins?campaign=instagram#menu

The last two, { state, key }, are React Router specific.
Location Pathname
This is the part of URL after the origin, so for https://example.com/teams/hotspurs the pathname is /teams/hotspurs. This is the only part of the location that routes match against.
Location Search
People use a lot of different terms for this part of the URL:

location search
search params
URL search params
query string

In React Router we call it the "location search". However, location search is a serialized version of URLSearchParams. So sometimes we might call it "URL search params" as well.
// given a location like this:
let location = {
  pathname: "/bbq/pig-pickins",
  search: "?campaign=instagram&popular=true",
  hash: "",
  state: null,
  key: "aefz24ie",
};

// we can turn the location.search into URLSearchParams
let params = new URLSearchParams(location.search);
params.get("campaign"); // "instagram"
params.get("popular"); // "true"
params.toString(); // "campaign=instagram&popular=true",

When being precise, refer to the serialized string version as "search" and the parsed version as "search params", but it's common to use the terms interchangeably when precision isn't important.
Location Hash
Hashes in URLs indicate a scroll position on the current page. Before the window.history.pushState API was introduced, web developers did client side routing exclusively with the hash portion of the URL, it was the only part we could manipulate without making a new request to the server. However, today we can use it for its designed purpose.
Location State
You may have wondered why the window.history.pushState() API is called "push state". State? Aren't we just changing the URL? Shouldn't it be history.push? Well, we weren't in the room when the API was designed, so we're not sure why "state" was the focus, but it is a cool feature of browsers nonetheless.
Browsers let us persist information about a navigation by passing a value to pushState. When the user clicks back, the value on history.state changes to whatever was "pushed" before.
window.history.pushState("look ma!", undefined, "/contact");
window.history.state; // "look ma!"
// user clicks back
window.history.state; // undefined
// user clicks forward
window.history.state; // "look ma!"

For illustration. You don't read history.state directly in React Router apps
React Router takes advantage of this browser feature, abstracts it a bit, and surfaces the values on the location instead of history.
You can think about location.state just like location.hash or location.search except instead of putting the values in the URL it's hidden--like a super secret piece of the URL only the programmer knows about.
A couple of great use-cases for location state are:

Telling the next page where the user came from and branching the UI. The most popular implementation here is showing a record in a modal if the user clicked on an item in a grid view, but if they show up to the URL directly, show the record in its own layout (pinterest, old instagram).
Sending a partial record from a list to the next screen so it can render the partial data immediately and then fetching the rest of the data afterward.

You set location state in two ways: on <Link> or navigate:
<Link to="/pins/123" state={{ fromDashboard: true }} />;

let navigate = useNavigate();
navigate("/users/123", { state: partialUser });

And on the next page you can access it with useLocation:
let location = useLocation();
location.state;

Location state values will get serialized, so something like new Date() will be turned into a string.
Location Key
Each location gets a unique key. This is useful for advanced cases like location-based scroll management, client side data caching, and more. Because each new location gets a unique key, you can build abstractions that store information in a plain object, new Map(), or even locationStorage.
For example, a very basic client side data cache could store values by location key (and the fetch URL) and skip fetching the data when the user clicks back into it:
let cache = new Map();

function useFakeFetch(URL) {
  let location = useLocation();
  let cacheKey = location.key + URL;
  let cached = cache.get(cacheKey);

  let [data, setData] = useState(() => {
    // initialize from the cache
    return cached || null;
  });

  let [state, setState] = useState(() => {
    // avoid the fetch if cached
    return cached ? "done" : "loading";
  });

  useEffect(() => {
    if (state === "loading") {
      let controller = new AbortController();
      fetch(URL, { signal: controller.signal })
        .then((res) => res.json())
        .then((data) => {
          if (controller.signal.aborted) return;
          // set the cache
          cache.set(cacheKey, data);
          setData(data);
        });
      return () => controller.abort();
    }
  }, [state, cacheKey]);

  useEffect(() => {
    setState("loading");
  }, [URL]);

  return data;
}

Matching
On the initial render, and when the history stack changes, React Router will match the location against your route config to come up with a set of matches to render.
Defining Routes
A route config is a tree of routes that looks something like this:
<Routes>
  <Route path="/" element={<App />}>
    <Route index element={<Home />} />
    <Route path="teams" element={<Teams />}>
      <Route path=":teamId" element={<Team />} />
      <Route path=":teamId/edit" element={<EditTeam />} />
      <Route path="new" element={<NewTeamForm />} />
      <Route index element={<LeagueStandings />} />
    </Route>
  </Route>
  <Route element={<PageLayout />}>
    <Route path="/privacy" element={<Privacy />} />
    <Route path="/tos" element={<Tos />} />
  </Route>
  <Route path="contact-us" element={<Contact />} />
</Routes>

The <Routes> component recurses through its props.children, strips their props, and generates an object like this:
let routes = [
  {
    element: <App />,
    path: "/",
    children: [
      {
        index: true,
        element: <Home />,
      },
      {
        path: "teams",
        element: <Teams />,
        children: [
          {
            index: true,
            element: <LeagueStandings />,
          },
          {
            path: ":teamId",
            element: <Team />,
          },
          {
            path: ":teamId/edit",
            element: <EditTeam />,
          },
          {
            path: "new",
            element: <NewTeamForm />,
          },
        ],
      },
    ],
  },
  {
    element: <PageLayout />,
    children: [
      {
        element: <Privacy />,
        path: "/privacy",
      },
      {
        element: <Tos />,
        path: "/tos",
      },
    ],
  },
  {
    element: <Contact />,
    path: "/contact-us",
  },
];

In fact, instead of <Routes> you can use the hook useRoutes(routesGoHere) instead. That's all <Routes> is doing.
As you can see, routes can define multiple segments like :teamId/edit, or just one like :teamId. All of the segments down a branch of the route config are added together to create a final path pattern for a route.
Match Params
Note the :teamId segments. This is what we call a dynamic segment of the path pattern, meaning it doesn't match the URL statically (the actual characters) but it matches it dynamically. Any value can fill in for :teamId. Both /teams/123 or /teams/cupcakes will match. We call the parsed values URL params. So in this case our teamId param would be "123" or "cupcakes". We'll see how to use them in your app in the Rendering section.
Ranking Routes
If we add up all the segments of all the branches of our route config, we end up with the following path patterns that our app responds to:
[
  "/",
  "/teams",
  "/teams/:teamId",
  "/teams/:teamId/edit",
  "/teams/new",
  "/privacy",
  "/tos",
  "/contact-us",
];

Now this is where things get really interesting. Consider the URL /teams/new. Which pattern in that list matches the URL?
That's right, two of them!
/teams/new
/teams/:teamId

React Router has to make a decision here, there can be only one. Many routers, both client side and server side, will simply process the patterns in the order in which they were defined. First to match wins. In this case we would match / and render the <Home/> component. Definitely not what we wanted. These kinds of routers require us to order our routes perfectly to get the expected result. This is how React Router has worked up until v6, but now it's much smarter.
Looking at those patterns, you intuitively know that we want /teams/new to match the URL /teams/new. It's a perfect match! React Router also knows that. When matching, it will rank your routes according the number of segments, static segments, dynamic segments, star patterns, etc. and pick the most specific match. You'll never have to think about ordering your routes.
Pathless Routes
You may have noticed the weird routes from earlier:
<Route index element={<Home />} />
<Route index element={<LeagueStandings />} />
<Route element={<PageLayout />} />

They don't even have a path, how can they be a route? This is where the word "route" in React Router is used pretty loosely. <Home/> and <LeagueStandings/> are index routes and <PageLayout/> is a layout route. We'll discuss how they work in the Rendering section. Neither really has much to do with matching.
Route Matches
When a route matches the URL, it's represented by a match object. A match for <Route path=":teamId" element={<Team/>}/> would look something like this:
{
  pathname: "/teams/firebirds",
  params: {
    teamId: "firebirds"
  },
  route: {
    element: <Team />,
    path: ":teamId"
  }
}

pathname holds the portion of the URL that matched this route (in our case it's all of it). params holds the parsed values from any dynamic segments that matched. Note that the param's object keys map directly to the name of the segment: :teamId becomes params.teamId.
Because our routes are a tree, a single URL can match an entire branch of the tree. Consider the URL /teams/firebirds, it would be the following route branch:
<Routes>
  <Route path="/" element={<App />}>
    <Route index element={<Home />} />
    <Route path="teams" element={<Teams />}>
      <Route path=":teamId" element={<Team />} />
      <Route path=":teamId/edit" element={<EditTeam />} />
      <Route path="new" element={<NewTeamForm />} />
      <Route index element={<LeagueStandings />} />
    </Route>
  </Route>
  <Route element={<PageLayout />}>
    <Route path="/privacy" element={<Privacy />} />
    <Route path="/tos" element={<Tos />} />
  </Route>
  <Route path="contact-us" element={<Contact />} />
</Routes>

React Router will create an array of matches from these routes and the url so it can render a nested UI that matches the route nesting.
[
  {
    pathname: "/",
    params: null,
    route: {
      element: <App />,
      path: "/",
    },
  },
  {
    pathname: "/teams",
    params: null,
    route: {
      element: <Teams />,
      path: "teams",
    },
  },
  {
    pathname: "/teams/firebirds",
    params: {
      teamId: "firebirds",
    },
    route: {
      element: <Team />,
      path: ":teamId",
    },
  },
];

Rendering
The final concept is rendering. Consider that the entry to your app looks like this:
const root = ReactDOM.createRoot(
  document.getElementById("root")
);
root.render(
  <BrowserRouter>
    <Routes>
      <Route path="/" element={<App />}>
        <Route index element={<Home />} />
        <Route path="teams" element={<Teams />}>
          <Route path=":teamId" element={<Team />} />
          <Route path="new" element={<NewTeamForm />} />
          <Route index element={<LeagueStandings />} />
        </Route>
      </Route>
      <Route element={<PageLayout />}>
        <Route path="/privacy" element={<Privacy />} />
        <Route path="/tos" element={<Tos />} />
      </Route>
      <Route path="contact-us" element={<Contact />} />
    </Routes>
  </BrowserRouter>
);

Let's use the /teams/firebirds URL as an example again. <Routes> will match the location to your route config, get a set of matches, and then render a React element tree like this:
<App>
  <Teams>
    <Team />
  </Teams>
</App>

Each match rendered inside the parent route's element is a really powerful abstraction. Most websites and apps share this characteristic: boxes inside of boxes inside of boxes, each with a navigation section that changes a child section of the page.
Outlets
This nested element tree won't happen automatically. <Routes> will render the first match's element for you (In our case that's <App/>). The next match's element is <Teams>. In order to render that, App needs to render an outlet.
function App() {
  return (
    <div>
      <GlobalNav />
      <Outlet />
      <GlobalFooter />
    </div>
  );
}

The Outlet component will always render the next match. That means <Teams> also needs an outlet to render <Team/>.
If the URL were /contact-us, the element tree would change to:
<ContactForm />

Because the contact form is not under the main <App> route.
If the URL were /teams/firebirds/edit, the element tree would change to:
<App>
  <Teams>
    <EditTeam />
  </Teams>
</App>

The outlet swaps out the child for the new child that matches, but the parent layout persists. It's subtle but very effective at cleaning up your components.
Index Routes
Remember the route config for /teams:
<Route path="teams" element={<Teams />}>
  <Route path=":teamId" element={<Team />} />
  <Route path="new" element={<NewTeamForm />} />
  <Route index element={<LeagueStandings />} />
</Route>

If the URL were /teams/firebirds, the element tree would be:
<App>
  <Teams>
    <Team />
  </Teams>
</App>

But if the URL were /teams, the element tree would be:
<App>
  <Teams>
    <LeagueStandings />
  </Teams>
</App>

League standings? How the heck did <Route index element={<LeagueStandings>}/> pop in there? It doesn't even have a path! The reason is that it's an index route. Index routes render in their parent route's outlet at the parent route's path.
Think of it this way, if you're not at one of the child routes' paths, the <Outlet> will render nothing in the UI:
<App>
  <Teams />
</App>

If all the teams are in a list on the left then an empty outlet means you've got a blank page on the right! Your UI needs something to fill the space: index routes to the rescue.
Another way to think of an index route is that it's the default child route when the parent matches but none of its children do.
Depending on the user interface, you might not need an index route, but if there is any sort of persistent navigation in the parent route you'll most likely want an index route to fill the space when the user hasn't clicked one of the items yet.
Layout Routes
Here's a part of our route config we haven't matched yet: /privacy. Let's look at the route config again, highlighting the matched routes:
<Routes>
  <Route path="/" element={<App />}>
    <Route index element={<Home />} />
    <Route path="teams" element={<Teams />}>
      <Route path=":teamId" element={<Team />} />
      <Route path=":teamId/edit" element={<EditTeam />} />
      <Route path="new" element={<NewTeamForm />} />
      <Route index element={<LeagueStandings />} />
    </Route>
  </Route>
  <Route element={<PageLayout />}>
    <Route path="/privacy" element={<Privacy />} />
    <Route path="/tos" element={<Tos />} />
  </Route>
  <Route path="contact-us" element={<Contact />} />
</Routes>

And the resulting element tree rendered will be:
<PageLayout>
  <Privacy />
</PageLayout>

Don't forget to add an <Outlet> to your layout where you would like child route elements to be rendered. Using {children} will not work as expected.
The PageLayout route is admittedly weird. We call it a layout route because it doesn't participate in the matching at all (though its children do). It only exists to make wrapping multiple child routes in the same layout simpler. If we didn't allow this then you'd have to handle layouts in two different ways: sometimes your routes do it for you, sometimes you do it manually with lots of layout component repetition throughout your app:
You can do it like this, but we recommend using a layout route
<Routes>
  <Route path="/" element={<App />}>
    <Route index element={<Home />} />
    <Route path="teams" element={<Teams />}>
      <Route path=":teamId" element={<Team />} />
      <Route path=":teamId/edit" element={<EditTeam />} />
      <Route path="new" element={<NewTeamForm />} />
      <Route index element={<LeagueStandings />} />
    </Route>
  </Route>
  <Route
    path="/privacy"
    element={
      <PageLayout>
        <Privacy />
      </PageLayout>
    }
  />
  <Route
    path="/tos"
    element={
      <PageLayout>
        <Tos />
      </PageLayout>
    }
  />
  <Route path="contact-us" element={<Contact />} />
</Routes>

So, yeah, the semantics of a layout "route" is a bit silly since it has nothing to do with the URL matching, but it's just too convenient to disallow.
Navigating
When the URL changes we call that a "navigation". There are two ways to navigate in React Router:

<Link>
navigate

Link
This is the primary means of navigation. Rendering a <Link> allows the user to change the URL when they click it. React Router will prevent the browser's default behavior and tell the history to push a new entry into the history stack. The location changes and the new matches will render.
However, links are accessible in that they:

Still render a <a href> so all default accessibility concerns are met (like keyboard, focusability, SEO, etc.)
Don't prevent the browser's default behavior if it's a right click or command/control click to "open in new tab"

Nested routes aren't just about rendering layouts; they also enable "relative links". Consider our teams route from before:
<Route path="teams" element={<Teams />}>
  <Route path=":teamId" element={<Team />} />
</Route>

The <Teams> component can render links like:
<Link to="psg" />
<Link to="new" />

The full path it links to will be /teams/psg and /teams/new. They inherit the route within which they are rendered. This makes it so your route components don't have to really know anything about the rest of the routes in the app. A very large amount of links just go one more segment deeper. You can rearrange your whole route config and these links will likely still work just fine. This is very valuable when building out a site in the beginning and the designs and layouts are shifting around.
Navigate Function
This function is returned from the useNavigate hook and allows you, the programmer, to change the URL whenever you want. You could do it on a timeout:
let navigate = useNavigate();
useEffect(() => {
  setTimeout(() => {
    navigate("/logout");
  }, 30000);
}, []);

Or after a form is submitted:
<form onSubmit={event => {
  event.preventDefault();
  let data = new FormData(event.target)
  let urlEncoded = new URLSearchParams(data)
  navigate("/create", { state: urlEncoded })
}}>

Like Link, navigate works with nested "to" values as well.
navigate("psg");

You should have a good reason to use navigate instead of <Link>. This makes us very sad:
<li onClick={() => navigate("/somewhere")} />

Aside from links and forms, very few interactions should change the URL because it introduces complexity around accessibility and user expectations.
Data Access
Finally, an application is going to want to ask React Router for a few pieces of information in order to build out the full UI. For this, React Router has a pile of hooks
let location = useLocation();
let urlParams = useParams();
let [urlSearchParams] = useSearchParams();

Review
Let's put it all together from the top!


You render your app:
const root = ReactDOM.createRoot(
  document.getElementById("root")
);
root.render(
  <BrowserRouter>
    <Routes>
      <Route path="/" element={<App />}>
        <Route index element={<Home />} />
        <Route path="teams" element={<Teams />}>
          <Route path=":teamId" element={<Team />} />
          <Route path="new" element={<NewTeamForm />} />
          <Route index element={<LeagueStandings />} />
        </Route>
      </Route>
      <Route element={<PageLayout />}>
        <Route path="/privacy" element={<Privacy />} />
        <Route path="/tos" element={<Tos />} />
      </Route>
      <Route path="contact-us" element={<Contact />} />
    </Routes>
  </BrowserRouter>
);



<BrowserRouter> creates a history, puts the initial location in to state, and subscribes to the URL.


<Routes> recurses its child routes to build a route config, matches those routes against the location, creates some route matches, and renders the first match's route element.


You render an <Outlet/> in each parent route.


The outlets render the next match in the route matches.


The user clicks a link


The link calls navigate()


The history changes the URL and notifies <BrowserRouter>.


<BrowserRouter> rerenders, start over at (2)!


That's it! We hope this guide has helped you gain a deeper understanding of the main concepts in React Router.© Remix Software, Inc.•Brand•Docs and examples CC 4.0

Migrating to RouterProvider v6.22.3 | React Router6.22.3Branchesmain (6.22.3)devVersions6.22.3v4/5.xv3.x Light Dark SystemMigrating to RouterProviderGetting StartedFeature Overview Tutorial Examples FAQs Main Concepts UpgradingMigrating to RouterProvider Upgrading from v5 Migrating from @reach/router RoutersPicking a Router 🆕createBrowserRouter 🆕createHashRouter 🆕createMemoryRouter 🆕createStaticHandler 🆕createStaticRouter 🆕RouterProvider 🆕StaticRouterProvider 🆕Router ComponentsBrowserRouter HashRouter MemoryRouter NativeRouter Router StaticRouter RouteRoute 🆕action 🆕errorElement 🆕hydrateFallbackElement 🆕lazy 🆕loader 🆕shouldRevalidate 🆕ComponentsAwait 🆕Form 🆕Link Link (RN) NavLink Navigate Outlet Route Routes ScrollRestoration 🆕HooksuseActionData 🆕useAsyncError 🆕useAsyncValue 🆕useBeforeUnload 🆕useBlocker useFetcher 🆕useFetchers 🆕useFormAction 🆕useHref useInRouterContext useLinkClickHandler useLinkPressHandler useLoaderData 🆕useLocation useMatch useMatches 🆕useNavigate useNavigation 🆕useNavigationType useOutlet useOutletContext useParams unstable_usePrompt useResolvedPath useRevalidator 🆕useRouteError 🆕useRouteLoaderData 🆕useRoutes useSearchParams useSearchParams (RN) useSubmit 🆕unstable_useViewTransitionState Fetch Utilitiesjson 🆕redirect 🆕redirectDocument 🆕UtilitiescreateRoutesFromChildren createRoutesFromElements createSearchParams defer 🆕generatePath isRouteErrorResponse 🆕Location matchPath matchRoutes renderMatches resolvePath GuidesServer-Side Rendering Contributing API Development Strategy 🆕Data Library Integration Deferred Data 🆕Working With FormData 🆕Index Query Param 🆕Getting StartedFeature Overview Tutorial Examples FAQs Main Concepts UpgradingMigrating to RouterProvider Upgrading from v5 Migrating from @reach/router RoutersPicking a Router 🆕createBrowserRouter 🆕createHashRouter 🆕createMemoryRouter 🆕createStaticHandler 🆕createStaticRouter 🆕RouterProvider 🆕StaticRouterProvider 🆕Router ComponentsBrowserRouter HashRouter MemoryRouter NativeRouter Router StaticRouter RouteRoute 🆕action 🆕errorElement 🆕hydrateFallbackElement 🆕lazy 🆕loader 🆕shouldRevalidate 🆕ComponentsAwait 🆕Form 🆕Link Link (RN) NavLink Navigate Outlet Route Routes ScrollRestoration 🆕HooksuseActionData 🆕useAsyncError 🆕useAsyncValue 🆕useBeforeUnload 🆕useBlocker useFetcher 🆕useFetchers 🆕useFormAction 🆕useHref useInRouterContext useLinkClickHandler useLinkPressHandler useLoaderData 🆕useLocation useMatch useMatches 🆕useNavigate useNavigation 🆕useNavigationType useOutlet useOutletContext useParams unstable_usePrompt useResolvedPath useRevalidator 🆕useRouteError 🆕useRouteLoaderData 🆕useRoutes useSearchParams useSearchParams (RN) useSubmit 🆕unstable_useViewTransitionState Fetch Utilitiesjson 🆕redirect 🆕redirectDocument 🆕UtilitiescreateRoutesFromChildren createRoutesFromElements createSearchParams defer 🆕generatePath isRouteErrorResponse 🆕Location matchPath matchRoutes renderMatches resolvePath GuidesServer-Side Rendering Contributing API Development Strategy 🆕Data Library Integration Deferred Data 🆕Working With FormData 🆕Index Query Param 🆕On this pageDifferencesMigratingCurrent ApplicationAdd RouterProvider with a root splat routeStart lifting routes and leveraging the data APIsFAQBut I've got stuff between <BrowserRouter> and <Routes>On this pageDifferencesMigratingCurrent ApplicationAdd RouterProvider with a root splat routeStart lifting routes and leveraging the data APIsFAQBut I've got stuff between <BrowserRouter> and <Routes>Migrating to RouterProvider
When we originally began bringing the Remix Data APIs over to React Router we realized that they brought about a pretty different way of structuring your routes. Instead of discovering routes via the <Routes> component as React rendered the component tree, we needed to lift the route definitions so we could decouple fetching from rendering.
This brought about an interesting conundrum. We've got tons of v6 BrowserRouter apps out there happily defining their routes via <Routes> components -- how can we provide them with a smooth upgrade experience that doesn't require a big-bang migration to the new approach? This ruled out a new major version and we focused on adding these new features in a fully backwards compatible way that would provide users an incremental upgrade path from BrowserRouter to RouterProvider.
Differences
The first thing to be aware of is the presence of a handful of new Data APIs that only work on routes defined via the new data routers (i.e., createBrowserRouter). These include a few categories of APIs:

Route-level data APIs such as loader, action, shouldRevalidate, handle, and lazy
In-component data hooks such as useLoaderData, useActionData, useFetcher, useMatches, useNavigation, etc.
Error-handling APIs such as route.errorElement, route.ErrorBoundary, and useRouteError

The rest of the APIs that existed prior to v6.4.0 are still usable in both BrowserRouter and RouterProvider apps. These include common hooks/components such as useNavigate, useLocation, useParams, <Link>, <Outlet />, etc.
Migrating
We built the new <RouterProvider> component such that it would enable the new Data APIs on routes defined at the root router, while not excluding descendant <Routes> trees so commonly used in BrowserRouter apps. This was explicitly to allow incremental migration from one to the other. Let's take a look at how we would do this.
Current Application
Let's assume we've got a current application with 2 descendant route trees, and assume these routes are all doing in-component data fetching, and rendering their own loading and error states.
import {
  BrowserRouter,
  Link,
  Route,
  Routes,
} from "react-router-dom";

export default function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/blog/*" element={<BlogApp />} />
        <Route path="/users/*" element={<UserApp />} />
      </Routes>
    </BrowserRouter>
  );
}

function Home() {
  return (
    <>
      <h1>Welcome!</h1>
      <p>
        Check out the <Link to="/blog">blog</Link> or the{" "}
        <Link to="users">users</Link> section
      </p>
    </>
  );
}

function BlogApp() {
  return (
    <Routes>
      <Route index element={<h1>Blog Index</h1>} />
      <Route path="posts" element={<h1>Blog Posts</h1>} />
    </Routes>
  );
}

function UserApp() {
  return (
    <Routes>
      <Route index element={<h1>Users Index</h1>} />
    </Routes>
  );
}

Add RouterProvider with a root splat route
We can render this application inside a RouterProvider with only a few small changes:

Change your current App component to Root
Remove the <BrowserRouter> component
Create a data router singleton with a splat route for the Root element
Add a new App component rendering a <RouterProvider>

import {
  createBrowserRouter,
  Link,
  Route,
  RouterProvider,
  Routes,
} from "react-router-dom";

// 3️⃣ Router singleton created
const router = createBrowserRouter([
  { path: "*", Component: Root },
]);

// 4️⃣ RouterProvider added
export default function App() {
  return <RouterProvider router={router} />;
}

// 1️⃣ Changed from App to Root
function Root() {
  // 2️⃣ `BrowserRouter` component removed, but the <Routes>/<Route>
  // component below are unchanged
  return (
    <Routes>
      <Route path="/" element={<Home />} />
      <Route path="/blog/*" element={<BlogApp />} />
      <Route path="/users/*" element={<UserApp />} />
    </Routes>
  );
}

function Home() {
  /* Unchanged */
}
function BlogApp() {
  /* Unchanged */
}
function UserApp() {
  /* Unchanged */
}

🥳 Congrats - you're now rendering a data router app! But wait a minute - we can't use any of the new stuff yet since none of our routes are defined at the top with createBrowserRouter 😢. To access the new APIs, we need to start lifting routes one-by-one to the data router.
Start lifting routes and leveraging the data APIs
Let's start with the / route for the <Home> component. All we need to do is lift the <Route> definition up to the data router:
const router = createBrowserRouter([
  { path: "/", Component: Home }, // 🆕
  { path: "*", Component: Root },
]);

export default function App() {
  return <RouterProvider router={router} />;
}

function Root() {
  return (
    <Routes>
      {/* ⬆️ Home route lifted up to the data router */}
      <Route path="/blog/*" element={<BlogApp />} />
      <Route path="/users/*" element={<UserApp />} />
    </Routes>
  );
}

Now you can add data APIs to your home route (loader, action, errorElement) and start leveraging data hooks inside your Home component (useLoaderData, useActionData, useFetcher, <Form>, etc.).
Now let's look at lifting the Blog App upwards, but still doing it one leaf route at a time. In order to lift the /blog index route up, we need the /blog/* splat route lifted as well, but we can still render the /blog/posts route where it is and do that separately.
const router = createBrowserRouter([
  { path: "/", Component: Home },
  {
    // Lifted blog splat route
    path: "/blog/*",
    children: [
      // New blog index route
      { index: true, Component: () => <h1>Blog Index</h1> },
      // Blog subapp splat route added for /blog/posts matching
      { path: "*", Component: BlogApp },
    ],
  },
  { path: "*", Component: Root },
]);

export default function App() {
  return <RouterProvider router={router} />;
}

function Root() {
  return (
    <Routes>
      {/* ⬆️ Blog splat route lifted */}
      <Route path="/users/*" element={<UserApp />} />
    </Routes>
  );
}

function BlogApp() {
  return (
    <Routes>
      {/* ⬆️ Blog index route lifted */}
      <Route path="posts" element={<h1>Blog Posts</h1>} />
    </Routes>
  );
}

And now your blog index route can participate in data loading.
You can keep doing this one route at a time until you've eventually converted all of your routes to data routes and can no longer use any nested <Routes> to define your routing tree. To avoid bundle bloat, it's recommended to leverage the route.lazy prop to lazily load your routes.
FAQ
But I've got stuff between <BrowserRouter> and <Routes>
Many folks render an app shell around their <Routes> via something like the following:
export default function App() {
  return (
    <BrowserRouter>
      <header>
        <h1>My Super Cool App</h1>
        <NavMenu />
      </header>
      <main>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/blog/*" element={<BlogApp />} />
          <Route path="/users/*" element={<UserApp />} />
        </Routes>
      </main>
      <footer>©️ me 2023</footer>
    </BrowserRouter>
  );
}

If you find yourself in this situation, don't worry - there's a straightforward solution you can do before starting the above migration.
This is quite common but poses a problem in the above migration approach since we need to lift things to RouterProvider route-by-route, but this "app shell" stuff isn't part of a route...but it could be! That "app shell" is really nothing more than a layout route with an <Outlet>! So before starting the above migration, just move this "app shell" into a pathless layout route around your routes as follows:
export default function App() {
  return (
    <BrowserRouter>
      <Routes>
        {/* 1️⃣ Wrap your routes in a pathless layout route */}
        <Route element={<Layout />}>
          <Route path="/" element={<Home />} />
          <Route path="/blog/*" element={<BlogApp />} />
          <Route path="/users/*" element={<UserApp />} />
        </Route>
      </Routes>
    </BrowserRouter>
  );
}

function Layout() {
  return (
    <>
      <header>
        <h1>My Super Cool App</h1>
        <NavMenu />
      </header>
      <main>
        {/* 2️⃣ Render the app routes via the Layout Outlet */}
        <Outlet />
      </main>
      <footer>©️ me 2023</footer>
    </>
  );
}

Once you've done that, you can proceed with the above migration strategy and start lifting routes into your RouterProvider one-by-one. You'll likely want to lift the layout route first so all of the children can nest inside of it.© Remix Software, Inc.•Brand•Docs and examples CC 4.0

Upgrading from v5 v6.22.3 | React Router6.22.3Branchesmain (6.22.3)devVersions6.22.3v4/5.xv3.x Light Dark SystemUpgrading from v5Getting StartedFeature Overview Tutorial Examples FAQs Main Concepts UpgradingMigrating to RouterProvider Upgrading from v5 Migrating from @reach/router RoutersPicking a Router 🆕createBrowserRouter 🆕createHashRouter 🆕createMemoryRouter 🆕createStaticHandler 🆕createStaticRouter 🆕RouterProvider 🆕StaticRouterProvider 🆕Router ComponentsBrowserRouter HashRouter MemoryRouter NativeRouter Router StaticRouter RouteRoute 🆕action 🆕errorElement 🆕hydrateFallbackElement 🆕lazy 🆕loader 🆕shouldRevalidate 🆕ComponentsAwait 🆕Form 🆕Link Link (RN) NavLink Navigate Outlet Route Routes ScrollRestoration 🆕HooksuseActionData 🆕useAsyncError 🆕useAsyncValue 🆕useBeforeUnload 🆕useBlocker useFetcher 🆕useFetchers 🆕useFormAction 🆕useHref useInRouterContext useLinkClickHandler useLinkPressHandler useLoaderData 🆕useLocation useMatch useMatches 🆕useNavigate useNavigation 🆕useNavigationType useOutlet useOutletContext useParams unstable_usePrompt useResolvedPath useRevalidator 🆕useRouteError 🆕useRouteLoaderData 🆕useRoutes useSearchParams useSearchParams (RN) useSubmit 🆕unstable_useViewTransitionState Fetch Utilitiesjson 🆕redirect 🆕redirectDocument 🆕UtilitiescreateRoutesFromChildren createRoutesFromElements createSearchParams defer 🆕generatePath isRouteErrorResponse 🆕Location matchPath matchRoutes renderMatches resolvePath GuidesServer-Side Rendering Contributing API Development Strategy 🆕Data Library Integration Deferred Data 🆕Working With FormData 🆕Index Query Param 🆕Getting StartedFeature Overview Tutorial Examples FAQs Main Concepts UpgradingMigrating to RouterProvider Upgrading from v5 Migrating from @reach/router RoutersPicking a Router 🆕createBrowserRouter 🆕createHashRouter 🆕createMemoryRouter 🆕createStaticHandler 🆕createStaticRouter 🆕RouterProvider 🆕StaticRouterProvider 🆕Router ComponentsBrowserRouter HashRouter MemoryRouter NativeRouter Router StaticRouter RouteRoute 🆕action 🆕errorElement 🆕hydrateFallbackElement 🆕lazy 🆕loader 🆕shouldRevalidate 🆕ComponentsAwait 🆕Form 🆕Link Link (RN) NavLink Navigate Outlet Route Routes ScrollRestoration 🆕HooksuseActionData 🆕useAsyncError 🆕useAsyncValue 🆕useBeforeUnload 🆕useBlocker useFetcher 🆕useFetchers 🆕useFormAction 🆕useHref useInRouterContext useLinkClickHandler useLinkPressHandler useLoaderData 🆕useLocation useMatch useMatches 🆕useNavigate useNavigation 🆕useNavigationType useOutlet useOutletContext useParams unstable_usePrompt useResolvedPath useRevalidator 🆕useRouteError 🆕useRouteLoaderData 🆕useRoutes useSearchParams useSearchParams (RN) useSubmit 🆕unstable_useViewTransitionState Fetch Utilitiesjson 🆕redirect 🆕redirectDocument 🆕UtilitiescreateRoutesFromChildren createRoutesFromElements createSearchParams defer 🆕generatePath isRouteErrorResponse 🆕Location matchPath matchRoutes renderMatches resolvePath GuidesServer-Side Rendering Contributing API Development Strategy 🆕Data Library Integration Deferred Data 🆕Working With FormData 🆕Index Query Param 🆕On this pageBackwards Compatibility PackageIntroductionUpgrade to React v16.8Upgrade to React Router v5.1Remove <Redirect>s inside <Switch>Refactor custom <Route>sShip it!Upgrade to React Router v6Upgrade all <Switch> elements to <Routes>Relative Routes and LinksAdvantages of <Route element>Note on <Route path> patternsNote on <Link to> valuesPass <Link> state as separate propUse useRoutes instead of react-router-configUse useNavigate instead of useHistoryRemove <Link> component propRename <NavLink exact> to <NavLink end>Remove activeClassName and activeStyle props from <NavLink />Get StaticRouter from react-router-dom/serverReplace useRouteMatch with useMatchChange the order of arguments passed to matchPath. Change pathPattern options.<Prompt> is not currently supportedWhat did we miss?On this pageBackwards Compatibility PackageIntroductionUpgrade to React v16.8Upgrade to React Router v5.1Remove <Redirect>s inside <Switch>Refactor custom <Route>sShip it!Upgrade to React Router v6Upgrade all <Switch> elements to <Routes>Relative Routes and LinksAdvantages of <Route element>Note on <Route path> patternsNote on <Link to> valuesPass <Link> state as separate propUse useRoutes instead of react-router-configUse useNavigate instead of useHistoryRemove <Link> component propRename <NavLink exact> to <NavLink end>Remove activeClassName and activeStyle props from <NavLink />Get StaticRouter from react-router-dom/serverReplace useRouteMatch with useMatchChange the order of arguments passed to matchPath. Change pathPattern options.<Prompt> is not currently supportedWhat did we miss?Upgrading from v5
Backwards Compatibility Package
Instead of upgrading and updating all of your code at once (which is incredibly difficult and prone to bugs), the backwards compatibility package enables you to upgrade one component, one hook, and one route at a time by running both v5 and v6 in parallel. Any code you haven't touched is still running the very same code it was before. Once all components are exclusively using the v6 APIs, your app no longer needs the compatibility package and is running on v6. The official guide can be found here.
We recommend using the backwards compatibility package to upgrade apps that have more than a few routes. Otherwise, we hope this guide will help you do the upgrade all at once!
Introduction
React Router version 6 introduces several powerful new features, as well as improved compatibility with the latest versions of React. It also introduces a few breaking changes from version 5. This document is a comprehensive guide on how to upgrade your v4/5 app to v6 while hopefully being able to ship as often as possible as you go.
The examples in this guide will show code samples of how you might have built something in a v5 app, followed by how you would accomplish the same thing in v6. There will also be an explanation of why we made this change and how it's going to improve both your code and the overall user experience of people who are using your app.
In general, the process looks like this:

Upgrade to React v16.8 or greater
Upgrade to React Router v5.1

Remove <Redirect>s inside <Switch>
Refactor custom <Route>s


Upgrade to React Router v6

The following is a detailed breakdown of each step that should help you migrate quickly and with confidence to v6.
Upgrade to React v16.8
React Router v6 makes heavy use of React hooks, so you'll need to be on React 16.8 or greater before attempting the upgrade to React Router v6. The good news is that React Router v5 is compatible with React >= 15, so if you're on v5 (or v4) you should be able to upgrade React without touching any of your router code.
Once you've upgraded to React 16.8, you should deploy your app. Then you can come back later and pick up where you left off.
Upgrade to React Router v5.1
It will be easier to make the switch to React Router v6 if you upgrade to v5.1 first. In v5.1, we released an enhancement to the handling of <Route children> elements that will help smooth the transition to v6. Instead of using <Route component> and <Route render> props, just use regular element <Route children> everywhere and use hooks to access the router's internal state.
// v4 and v5 before 5.1
function User({ id }) {
  // ...
}

function App() {
  return (
    <Switch>
      <Route exact path="/" component={Home} />
      <Route path="/about" component={About} />
      <Route
        path="/users/:id"
        render={({ match }) => (
          <User id={match.params.id} />
        )}
      />
    </Switch>
  );
}

// v5.1 preferred style
function User() {
  let { id } = useParams();
  // ...
}

function App() {
  return (
    <Switch>
      <Route exact path="/">
        <Home />
      </Route>
      <Route path="/about">
        <About />
      </Route>
      {/* Can also use a named `children` prop */}
      <Route path="/users/:id" children={<User />} />
    </Switch>
  );
}

You can read more about v5.1's hooks API and the rationale behind the move to regular elements on our blog.
In general, React Router v5.1 (and v6) favors elements over components (or "element types"). There are a few reasons for this, but we'll discuss more further down when we discuss v6's <Route> API.
When you use regular React elements you get to pass the props explicitly. This helps with code readability and maintenance over time. If you were using <Route render> to get a hold of the params, you can just
useParams inside your route component instead.
Along with the upgrade to v5.1, you should replace any usage of withRouter with hooks. You should also get rid of any "floating" <Route> elements that are not inside a <Switch>. Again, the blog post about v5.1 explains how to do this in greater detail.
In summary, to upgrade from v4/5 to v5.1, you should:

Use <Route children> instead of <Route render> and/or <Route component>
props
Use our hooks API to
access router state like the current location and params
Replace all uses of withRouter with hooks
Replace any <Route>s that are not inside a <Switch> with useRouteMatch,
or wrap them in a <Switch>

Remove <Redirect>s inside <Switch>
Remove any <Redirect> elements that are directly inside a <Switch>.
If you want to redirect on the initial render, you should move the redirect logic to your server (we wrote more about this here).
If you want to redirect client-side, move your <Redirect> into a <Route render> prop.
// Change this:
<Switch>
  <Redirect from="about" to="about-us" />
</Switch>

// to this:
<Switch>
  <Route path="about" render={() => <Redirect to="about-us" />} />
</Switch>

Normal <Redirect> elements that are not inside a <Switch> are ok to remain. They will become <Navigate> elements in v6.
Refactor custom <Route>s
Replace any elements inside a <Switch> that are not plain <Route> elements with a regular <Route>. This includes any <PrivateRoute>-style custom components.
You can read more about the rationale behind this here, including some tips about how to use a <Route render> prop in v5 to achieve the same effect.
Ship it!
Again, once your app is upgraded to v5.1 you should test and deploy it, and pick this guide back up when you're ready to continue.
Upgrade to React Router v6
Heads up: This is the biggest step in the migration and will probably take the most time and effort.
For this step, you'll need to install React Router v6. If you're managing dependencies via npm:
$ npm install react-router-dom
# or, for a React Native app
$ npm install react-router-native

You'll also want to remove the history dependency from your package.json. The history library is a direct dependency of v6 (not a peer dep), so you won't ever import or use it directly. Instead, you'll use the useNavigate() hook for all navigation (see below).
Upgrade all <Switch> elements to <Routes>
React Router v6 introduces a Routes component that is kind of like Switch, but a lot more powerful. The main advantages of Routes over Switch are:

All <Route>s and <Link>s inside a <Routes> are relative. This leads to
leaner and more predictable code in <Route path> and <Link to>
Routes are chosen based on the best match instead of being traversed in order.
This avoids bugs due to unreachable routes because they were defined later
in your <Switch>
Routes may be nested in one place instead of being spread out in different
components. In small to medium-sized apps, this lets you easily see all your
routes at once. In large apps, you can still nest routes in bundles that you
load dynamically via React.lazy

In order to use v6, you'll need to convert all your <Switch> elements to <Routes>. If you already made the upgrade to v5.1, you're halfway there.
First, let's talk about relative routes and links in v6.
Relative Routes and Links
In v5, you had to be very explicit about how you wanted to nest your routes and links. In both cases, if you wanted nested routes and links you had to build the <Route path> and <Link to> props from the parent route's match.url and match.path properties. Additionally, if you wanted to nest routes, you had to put them in the child route's component.
// This is a React Router v5 app
import {
  BrowserRouter,
  Switch,
  Route,
  Link,
  useRouteMatch,
} from "react-router-dom";

function App() {
  return (
    <BrowserRouter>
      <Switch>
        <Route exact path="/">
          <Home />
        </Route>
        <Route path="/users">
          <Users />
        </Route>
      </Switch>
    </BrowserRouter>
  );
}

function Users() {
  // In v5, nested routes are rendered by the child component, so
  // you have <Switch> elements all over your app for nested UI.
  // You build nested routes and links using match.url and match.path.
  let match = useRouteMatch();

  return (
    <div>
      <nav>
        <Link to={`${match.url}/me`}>My Profile</Link>
      </nav>

      <Switch>
        <Route path={`${match.path}/me`}>
          <OwnUserProfile />
        </Route>
        <Route path={`${match.path}/:id`}>
          <UserProfile />
        </Route>
      </Switch>
    </div>
  );
}

This is the same app in v6:
// This is a React Router v6 app
import {
  BrowserRouter,
  Routes,
  Route,
  Link,
} from "react-router-dom";

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="users/*" element={<Users />} />
      </Routes>
    </BrowserRouter>
  );
}

function Users() {
  return (
    <div>
      <nav>
        <Link to="me">My Profile</Link>
      </nav>

      <Routes>
        <Route path=":id" element={<UserProfile />} />
        <Route path="me" element={<OwnUserProfile />} />
      </Routes>
    </div>
  );
}

A few important things to notice about v6 in this example:

<Route path> and <Link to> are relative. This means that they
automatically build on the parent route's path and URL so you don't have to
manually interpolate match.url or match.path
<Route exact> is gone. Instead, routes with descendant routes (defined in
other components) use a trailing * in their path to indicate they match
deeply
You may put your routes in whatever order you wish and the router will
automatically detect the best route for the current URL. This prevents bugs
due to manually putting routes in the wrong order in a <Switch>

You may have also noticed that all <Route children> from the v5 app changed to <Route element> in v6. Assuming you followed the upgrade steps to v5.1, this should be as simple as moving your route element from the child position to a named element prop.

Advantages of <Route element>
In the section about upgrading to v5.1, we promised that we'd discuss the advantages of using regular elements instead of components (or element types) for rendering. Let's take a quick break from upgrading and talk about that now.
For starters, we see React itself taking the lead here with the <Suspense fallback={<Spinner />}> API. The fallback prop takes a React element, not a component. This lets you easily pass whatever props you want to your <Spinner> from the component that renders it.
Using elements instead of components means we don't have to provide a passProps-style API so you can get the props you need to your elements. For example, in a component-based API there is no good way to pass props to the <Profile> element that is rendered when <Route path=":userId" component={Profile} /> matches. Most React libraries who take this approach end up with either an API like <Route component={Profile} passProps={{ animate: true }} /> or use a render prop or higher-order component.
Also, in case you didn't notice, in v4 and v5 Route's rendering API became rather large. It went something like this:
// Ah, this is nice and simple!
<Route path=":userId" component={Profile} />

// But wait, how do I pass custom props to the <Profile> element??
// Hmm, maybe we can use a render prop in those situations?
<Route
  path=":userId"
  render={routeProps => (
    <Profile routeProps={routeProps} animate={true} />
  )}
/>

// Ok, now we have two ways to render something with a route. :/

// But wait, what if we want to render something when a route
// *doesn't* match the URL, like a Not Found page? Maybe we
// can use another render prop with slightly different semantics?
<Route
  path=":userId"
  children={({ match }) => (
    match ? (
      <Profile match={match} animate={true} />
    ) : (
      <NotFound />
    )
  )}
/>

// What if I want to get access to the route match, or I need
// to redirect deeper in the tree?
function DeepComponent(routeStuff) {
  // got routeStuff, phew!
}
export default withRouter(DeepComponent);

// Well hey, now at least we've covered all our use cases!
// ... *facepalm*

At least part of the reason for this API sprawl was that React did not provide any way for us to get the information from the <Route> to your route element, so we had to invent clever ways to get both the route data and your own custom props through to your elements: component, render props, passProps higher-order-components ... until hooks came along!
Now, the conversation above goes like this:
// Ah, nice and simple API. And it's just like the <Suspense> API!
// Nothing more to learn here.
<Route path=":userId" element={<Profile />} />

// But wait, how do I pass custom props to the <Profile>
// element? Oh ya, it's just an element. Easy.
<Route path=":userId" element={<Profile animate={true} />} />

// Ok, but how do I access the router's data, like the URL params
// or the current location?
function Profile({ animate }) {
  let params = useParams();
  let location = useLocation();
}

// But what about components deep in the tree?
function DeepComponent() {
  // oh right, same as anywhere else
  let navigate = useNavigate();
}

// Aaaaaaaaand we're done here.

Another important reason for using the element prop in v6 is that <Route children> is reserved for nesting routes. This is one of people's favorite features from v3 and @reach/router, and we're bringing it back in v6. Taking the code in the previous example one step further, we can hoist all <Route> elements into a single route config:
// This is a React Router v6 app
import {
  BrowserRouter,
  Routes,
  Route,
  Link,
  Outlet,
} from "react-router-dom";

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="users" element={<Users />}>
          <Route path="me" element={<OwnUserProfile />} />
          <Route path=":id" element={<UserProfile />} />
        </Route>
      </Routes>
    </BrowserRouter>
  );
}

function Users() {
  return (
    <div>
      <nav>
        <Link to="me">My Profile</Link>
      </nav>

      <Outlet />
    </div>
  );
}

This step is optional of course, but it's really nice for small to medium sized apps that don't have thousands of routes.
Notice how <Route> elements nest naturally inside a <Routes> element. Nested routes build their path by adding to the parent route's path. We didn't need a trailing * on <Route path="users"> this time because when the routes are defined in one spot the router is able to see all your nested routes.
You'll only need the trailing * when there is another <Routes> somewhere in that route's descendant tree. In that case, the descendant <Routes> will match on the portion of the pathname that remains (see the previous example for what this looks like in practice).
When using a nested config, routes with children should render an <Outlet> in order to render their child routes. This makes it easy to render layouts with nested UI.
Note on <Route path> patterns
React Router v6 uses a simplified path format. <Route path> in v6 supports only 2 kinds of placeholders: dynamic :id-style params and * wildcards. A * wildcard may be used only at the end of a path, not in the middle.
All of the following are valid route paths in v6:
/groups
/groups/admin
/users/:id
/users/:id/messages
/files/*
/files/:id/*

The following RegExp-style route paths are not valid in v6:
/users/:id?
/tweets/:id(\d+)
/files/*/cat.jpg
/files-*

We added the dependency on path-to-regexp in v4 to enable more advanced pattern matching. In v6 we are using a simpler syntax that allows us to predictably parse the path for ranking purposes. It also means we can stop depending on path-to-regexp, which is nice for bundle size.
If you were using any of path-to-regexp's more advanced syntax, you'll have to remove it and simplify your route paths. If you were using the RegExp syntax to do URL param validation (e.g. to ensure an id is all numeric characters) please know that we plan to add some more advanced param validation in v6 at some point. For now, you'll need to move that logic to the component the route renders, and let it branch its rendered tree after you parse the params.
If you were using <Route sensitive> you should move it to its containing <Routes caseSensitive> prop. Either all routes in a <Routes> element are case-sensitive or they are not.
One other thing to notice is that all path matching in v6 ignores the trailing slash on the URL. In fact, <Route strict> has been removed and has no effect in v6. This does not mean that you can't use trailing slashes if you need to. Your app can decide to use trailing slashes or not, you just can't render two different UIs client-side at <Route path="edit"> and <Route path="edit/">. You can still render two different UIs at those URLs (though we wouldn't recommend it), but you'll have to do it server-side.
Note on <Link to> values
In v5, a <Link to> value that does not begin with / was ambiguous; it depends on what the current URL is. For example, if the current URL is /users, a v5 <Link to="me"> would render a <a href="/me">. However, if the current URL has a trailing slash, like /users/, the same <Link to="me"> would render <a href="/users/me">. This makes it difficult to predict how links will behave, so in v5 we recommended that you build links from the root URL (using match.url) and not use relative <Link to> values.
React Router v6 fixes this ambiguity. In v6, a <Link to="me"> will always render the same <a href>, regardless of the current URL.
For example, a <Link to="me"> that is rendered inside a <Route path="users"> will always render a link to /users/me, regardless of whether or not the current URL has a trailing slash.
When you'd like to link back "up" to parent routes, use a leading .. segment in your <Link to> value, similar to what you'd do in a <a href>.
function App() {
  return (
    <Routes>
      <Route path="users" element={<Users />}>
        <Route path=":id" element={<UserProfile />} />
      </Route>
    </Routes>
  );
}

function Users() {
  return (
    <div>
      <h2>
        {/* This links to /users - the current route */}
        <Link to=".">Users</Link>
      </h2>

      <ul>
        {users.map((user) => (
          <li>
            {/* This links to /users/:id - the child route */}
            <Link to={user.id}>{user.name}</Link>
          </li>
        ))}
      </ul>
    </div>
  );
}

function UserProfile() {
  return (
    <div>
      <h2>
        {/* This links to /users - the parent route */}
        <Link to="..">All Users</Link>
      </h2>

      <h2>
        {/* This links to /users/:id - the current route */}
        <Link to=".">User Profile</Link>
      </h2>

      <h2>
        {/* This links to /users/mj - a "sibling" route */}
        <Link to="../mj">MJ</Link>
      </h2>
    </div>
  );
}

It may help to think about the current URL as if it were a directory path on the filesystem and <Link to> like the cd command line utility.
// If your routes look like this
<Route path="app">
  <Route path="dashboard">
    <Route path="stats" />
  </Route>
</Route>

// and the current URL is /app/dashboard (with or without
// a trailing slash)
<Link to="stats">               => <a href="/app/dashboard/stats">
<Link to="../stats">            => <a href="/app/stats">
<Link to="../../stats">         => <a href="/stats">
<Link to="../../../stats">      => <a href="/stats">

// On the command line, if the current directory is /app/dashboard
cd stats                        # pwd is /app/dashboard/stats
cd ../stats                     # pwd is /app/stats
cd ../../stats                  # pwd is /stats
cd ../../../stats               # pwd is /stats

Note: The decision to ignore trailing slashes while matching and creating relative paths was not taken lightly by our team. We consulted with a number of our friends and clients (who are also our friends!) about it. We found that most of us don't even understand how plain HTML relative links are handled with the trailing slash. Most people guessed it worked like cd on the command line (it does not). Also, HTML relative links don't have the concept of nested routes, they only worked on the URL, so we had to blaze our own trail here a bit. @reach/router set this precedent and it has worked out well for a couple of years.
In addition to ignoring trailing slashes in the current URL, it is important to note that <Link to=".."> will not always behave like <a href=".."> when your <Route path> matches more than one segment of the URL. Instead of removing just one segment of the URL, it will resolve based upon the parent route's path, essentially removing all path segments specified by that route.
function App() {
  return (
    <Routes>
      <Route path="users">
        <Route
          path=":id/messages"
          element={
            // This links to /users
            <Link to=".." />
          }
        />
      </Route>
    </Routes>
  );
}

This may seem like an odd choice, to make .. operate on routes instead of URL segments, but it's a huge help when working with * routes where an indeterminate number of segments may be matched by the *. In these scenarios, a single .. segment in your <Link to> value can essentially remove anything matched by the *, which lets you create more predictable links in * routes.
function App() {
  return (
    <Routes>
      <Route path=":userId">
        <Route path="messages" element={<UserMessages />} />
        <Route
          path="files/*"
          element={
            // This links to /:userId/messages, no matter
            // how many segments were matched by the *
            <Link to="../messages" />
          }
        />
      </Route>
    </Routes>
  );
}

Pass <Link> state as separate prop
The Link component in v6 accepts state as a separate prop instead of receiving it as part of the object passed to to so you'll need to update your Link components if they are using state:
import { Link } from "react-router-dom";

// Change this:
<Link to={{ pathname: "/home", state: state }} />

// to this:
<Link to="/home" state={state} />

The state value is still retrieved in the linked component using useLocation():
function Home() {
  const location = useLocation();
  const state = location.state;
  return <div>Home</div>;
}

Use useRoutes instead of react-router-config
All of the functionality from v5's react-router-config package has moved into core in v6. If you prefer/need to define your routes as JavaScript objects instead of using React elements, you're going to love this.
function App() {
  let element = useRoutes([
    // These are the same as the props you provide to <Route>
    { path: "/", element: <Home /> },
    { path: "dashboard", element: <Dashboard /> },
    {
      path: "invoices",
      element: <Invoices />,
      // Nested routes use a children property, which is also
      // the same as <Route>
      children: [
        { path: ":id", element: <Invoice /> },
        { path: "sent", element: <SentInvoices /> },
      ],
    },
    // Not found routes work as you'd expect
    { path: "*", element: <NotFound /> },
  ]);

  // The returned element will render the entire element
  // hierarchy with all the appropriate context it needs
  return element;
}

Routes defined in this way follow all of the same semantics as <Routes>. In fact, <Routes> is really just a wrapper around useRoutes.
We encourage you to give both <Routes> and useRoutes a shot and decide for yourself which one you prefer to use. Honestly, we like and use them both.
If you had cooked up some of your own logic around data fetching and rendering server-side, we have a low-level matchRoutes function available as well similar to the one we had in react-router-config.
Use useNavigate instead of useHistory
React Router v6 introduces a new navigation API that is synonymous with <Link> and provides better compatibility with suspense-enabled apps. We include both imperative and declarative versions of this API depending on your style and needs.
// This is a React Router v5 app
import { useHistory } from "react-router-dom";

function App() {
  let history = useHistory();
  function handleClick() {
    history.push("/home");
  }
  return (
    <div>
      <button onClick={handleClick}>go home</button>
    </div>
  );
}

In v6, this app should be rewritten to use the navigate API. Most of the time this means changing useHistory to useNavigate and changing the history.push or history.replace callsite.
// This is a React Router v6 app
import { useNavigate } from "react-router-dom";

function App() {
  let navigate = useNavigate();
  function handleClick() {
    navigate("/home");
  }
  return (
    <div>
      <button onClick={handleClick}>go home</button>
    </div>
  );
}

If you need to replace the current location instead of push a new one onto the history stack, use navigate(to, { replace: true }). If you need state, use navigate(to, { state }). You can think of the first argument to navigate as your <Link to> and the other arguments as the replace and state props.
If you prefer to use a declarative API for navigation (ala v5's Redirect component), v6 provides a Navigate component. Use it like:
import { Navigate } from "react-router-dom";

function App() {
  return <Navigate to="/home" replace state={state} />;
}

Note: Be aware that the v5 <Redirect /> uses replace logic by default (you may change it via push prop), on the other hand, the v6 <Navigate /> uses push logic by default and you may change it via replace prop.
// Change this:
<Redirect to="about" />
<Redirect to="home" push />

// to this:
<Navigate to="about" replace />
<Navigate to="home" />

If you're currently using go, goBack or goForward from useHistory to navigate backwards and forwards, you should also replace these with navigate with a numerical argument indicating where to move the pointer in the history stack. For example, here is some code using v5's useHistory hook:
// This is a React Router v5 app
import { useHistory } from "react-router-dom";

function App() {
  const { go, goBack, goForward } = useHistory();

  return (
    <>
      <button onClick={() => go(-2)}>
        Go 2 pages back
      </button>
      <button onClick={goBack}>Go back</button>
      <button onClick={goForward}>Go forward</button>
      <button onClick={() => go(2)}>
        Go 2 pages forward
      </button>
    </>
  );
}

Here is the equivalent app with v6:
// This is a React Router v6 app
import { useNavigate } from "react-router-dom";

function App() {
  const navigate = useNavigate();

  return (
    <>
      <button onClick={() => navigate(-2)}>
        Go 2 pages back
      </button>
      <button onClick={() => navigate(-1)}>Go back</button>
      <button onClick={() => navigate(1)}>
        Go forward
      </button>
      <button onClick={() => navigate(2)}>
        Go 2 pages forward
      </button>
    </>
  );
}

Again, one of the main reasons we are moving from using the history API directly to the navigate API is to provide better compatibility with React suspense. React Router v6 uses the useNavigation hook at the root of your component hierarchy. This lets us provide a smoother experience when user interaction needs to interrupt a pending route navigation, for example when they click a link to another route while a previously-clicked link is still loading. The navigate API is aware of the internal pending navigation state and will do a REPLACE instead of a PUSH onto the history stack, so the user doesn't end up with pages in their history that never actually loaded.
Note: The <Redirect> element from v5 is no longer supported as part of your route config (inside a <Routes>). This is due to upcoming changes in React that make it unsafe to alter the state of the router during the initial render. If you need to redirect immediately, you can either a) do it on your server (probably the best solution) or b) render a <Navigate> element in your route component. However, recognize that the navigation will happen in a useEffect.
Aside from suspense compatibility, navigate, like Link, supports relative navigation. For example:
// assuming we are at `/stuff`
function SomeForm() {
  let navigate = useNavigate();
  return (
    <form
      onSubmit={async (event) => {
        let newRecord = await saveDataFromForm(
          event.target
        );
        // you can build up the URL yourself
        navigate(`/stuff/${newRecord.id}`);
        // or navigate relative, just like Link
        navigate(`${newRecord.id}`);
      }}
    >
      {/* ... */}
    </form>
  );
}

Remove <Link> component prop
<Link> no longer supports the component prop for overriding the returned anchor tag. There are a few reasons for this.
First of all, a <Link> should pretty much always render an <a>. If yours does not, there's a good chance your app has some serious accessibility and usability problems, and that's no good. The browsers give us a lot of nice usability features with <a> and we want your users to get those for free!
That being said, maybe your app uses a CSS-in-JS library, or maybe you have a custom, fancy link component already in your design system that you'd like to render instead. The component prop may have worked well enough in a world before hooks, but now you can create your very own accessible Link component with just a few of our hooks:
import { FancyPantsLink } from "@fancy-pants/design-system";
import {
  useHref,
  useLinkClickHandler,
} from "react-router-dom";

const Link = React.forwardRef(
  (
    {
      onClick,
      replace = false,
      state,
      target,
      to,
      ...rest
    },
    ref
  ) => {
    let href = useHref(to);
    let handleClick = useLinkClickHandler(to, {
      replace,
      state,
      target,
    });

    return (
      <FancyPantsLink
        {...rest}
        href={href}
        onClick={(event) => {
          onClick?.(event);
          if (!event.defaultPrevented) {
            handleClick(event);
          }
        }}
        ref={ref}
        target={target}
      />
    );
  }
);

If you're using react-router-native, we provide useLinkPressHandler that works basically the same way. Just call that hook's returned function in your Link's onPress handler and you're all set.
Rename <NavLink exact> to <NavLink end>
This is a simple renaming of a prop to better align with the common practices of other libraries in the React ecosystem.
Remove activeClassName and activeStyle props from <NavLink />
As of v6.0.0-beta.3, the activeClassName and activeStyle props have been removed from NavLinkProps. Instead, you can pass a function to either style or className that will allow you to customize the inline styling or the class string based on the component's active state.
<NavLink
  to="/messages"
- style={{ color: 'blue' }}
- activeStyle={{ color: 'green' }}
+ style={({ isActive }) => ({ color: isActive ? 'green' : 'blue' })}
>
  Messages
</NavLink>

<NavLink
  to="/messages"
- className="nav-link"
- activeClassName="activated"
+ className={({ isActive }) => "nav-link" + (isActive ? " activated" : "")}
>
  Messages
</NavLink>

If you prefer to keep the v5 props, you can create your own <NavLink /> as a wrapper component for a smoother upgrade path.
import * as React from "react";
import { NavLink as BaseNavLink } from "react-router-dom";

const NavLink = React.forwardRef(
  ({ activeClassName, activeStyle, ...props }, ref) => {
    return (
      <BaseNavLink
        ref={ref}
        {...props}
        className={({ isActive }) =>
          [
            props.className,
            isActive ? activeClassName : null,
          ]
            .filter(Boolean)
            .join(" ")
        }
        style={({ isActive }) => ({
          ...props.style,
          ...(isActive ? activeStyle : null),
        })}
      />
    );
  }
);

Get StaticRouter from react-router-dom/server
The StaticRouter component has moved into a new bundle: react-router-dom/server.
// change
import { StaticRouter } from "react-router-dom";
// to
import { StaticRouter } from "react-router-dom/server";

This change was made both to follow more closely the convention established by the react-dom package and to help users understand better what a <StaticRouter> is for and when it should be used (on the server).
Replace useRouteMatch with useMatch
useMatch is very similar to v5's useRouteMatch, with a few key differences:

It uses our new path pattern matching algorithm
The pattern argument is now required
No longer accepts an array of patterns
When passing a pattern as an object, some of the options have been renamed to better align with other APIs in v6

useRouteMatch({ strict }) is now useMatch({ end })
useRouteMatch({ sensitive }) is now useMatch({ caseSensitive })


It returns a match object with a different shape

To see the exact API of the new useMatch hook and its type declaration, check out our API Reference.

Change the order of arguments passed to matchPath. Change pathPattern options.
Since version 6 the order of arguments passed to matchPath function has changed. Also pattern options has changed.

first argument is pathPattern object, then comes pathname
pathPattern doesn't include exact and strict options any more. New caseSensitive and end options has been added.

Please refactor it as follows:
Before:
// This is a React Router v5 app
import { matchPath } from "react-router-dom";

const match = matchPath("/users/123", {
  path: "/users/:id",
  exact: true, // Optional, defaults to false
  strict: false, // Optional, defaults to false
});

After:
// This is a React Router v6 app
import { matchPath } from "react-router-dom";

const match = matchPath(
  {
    path: "/users/:id",
    caseSensitive: false, // Optional, `true` == static parts of `path` should match case
    end: true, // Optional, `true` == pattern should match the entire URL pathname
  },
  "/users/123"
);

<Prompt> is not currently supported
<Prompt> from v5 (along with usePrompt and useBlocker from the v6 betas) are not included in the current released version of v6. We decided we'd rather ship with what we have than take even more time to nail down a feature that isn't fully baked. We will absolutely be working on adding this back in to v6 at some point in the near future, but not for our first stable release of 6.x.
We have since added implementations for useBlocker and unstable_usePrompt that you can use instead of <Prompt>
What did we miss?
Despite our best attempts at being thorough, it's very likely that we missed something. If you follow this upgrade guide and find that to be the case, please let us know. We are happy to help you figure out what to do with your v5 code to be able to upgrade and take advantage of all of the cool stuff in v6.
Good luck 🤘© Remix Software, Inc.•Brand•Docs and examples CC 4.0

Migrating from @reach/router v6.22.3 | React Router6.22.3Branchesmain (6.22.3)devVersions6.22.3v4/5.xv3.x Light Dark SystemMigrating from @reach/routerGetting StartedFeature Overview Tutorial Examples FAQs Main Concepts UpgradingMigrating to RouterProvider Upgrading from v5 Migrating from @reach/router RoutersPicking a Router 🆕createBrowserRouter 🆕createHashRouter 🆕createMemoryRouter 🆕createStaticHandler 🆕createStaticRouter 🆕RouterProvider 🆕StaticRouterProvider 🆕Router ComponentsBrowserRouter HashRouter MemoryRouter NativeRouter Router StaticRouter RouteRoute 🆕action 🆕errorElement 🆕hydrateFallbackElement 🆕lazy 🆕loader 🆕shouldRevalidate 🆕ComponentsAwait 🆕Form 🆕Link Link (RN) NavLink Navigate Outlet Route Routes ScrollRestoration 🆕HooksuseActionData 🆕useAsyncError 🆕useAsyncValue 🆕useBeforeUnload 🆕useBlocker useFetcher 🆕useFetchers 🆕useFormAction 🆕useHref useInRouterContext useLinkClickHandler useLinkPressHandler useLoaderData 🆕useLocation useMatch useMatches 🆕useNavigate useNavigation 🆕useNavigationType useOutlet useOutletContext useParams unstable_usePrompt useResolvedPath useRevalidator 🆕useRouteError 🆕useRouteLoaderData 🆕useRoutes useSearchParams useSearchParams (RN) useSubmit 🆕unstable_useViewTransitionState Fetch Utilitiesjson 🆕redirect 🆕redirectDocument 🆕UtilitiescreateRoutesFromChildren createRoutesFromElements createSearchParams defer 🆕generatePath isRouteErrorResponse 🆕Location matchPath matchRoutes renderMatches resolvePath GuidesServer-Side Rendering Contributing API Development Strategy 🆕Data Library Integration Deferred Data 🆕Working With FormData 🆕Index Query Param 🆕Getting StartedFeature Overview Tutorial Examples FAQs Main Concepts UpgradingMigrating to RouterProvider Upgrading from v5 Migrating from @reach/router RoutersPicking a Router 🆕createBrowserRouter 🆕createHashRouter 🆕createMemoryRouter 🆕createStaticHandler 🆕createStaticRouter 🆕RouterProvider 🆕StaticRouterProvider 🆕Router ComponentsBrowserRouter HashRouter MemoryRouter NativeRouter Router StaticRouter RouteRoute 🆕action 🆕errorElement 🆕hydrateFallbackElement 🆕lazy 🆕loader 🆕shouldRevalidate 🆕ComponentsAwait 🆕Form 🆕Link Link (RN) NavLink Navigate Outlet Route Routes ScrollRestoration 🆕HooksuseActionData 🆕useAsyncError 🆕useAsyncValue 🆕useBeforeUnload 🆕useBlocker useFetcher 🆕useFetchers 🆕useFormAction 🆕useHref useInRouterContext useLinkClickHandler useLinkPressHandler useLoaderData 🆕useLocation useMatch useMatches 🆕useNavigate useNavigation 🆕useNavigationType useOutlet useOutletContext useParams unstable_usePrompt useResolvedPath useRevalidator 🆕useRouteError 🆕useRouteLoaderData 🆕useRoutes useSearchParams useSearchParams (RN) useSubmit 🆕unstable_useViewTransitionState Fetch Utilitiesjson 🆕redirect 🆕redirectDocument 🆕UtilitiescreateRoutesFromChildren createRoutesFromElements createSearchParams defer 🆕generatePath isRouteErrorResponse 🆕Location matchPath matchRoutes renderMatches resolvePath GuidesServer-Side Rendering Contributing API Development Strategy 🆕Data Library Integration Deferred Data 🆕Working With FormData 🆕Index Query Param 🆕On this pageIntroductionUpgrading OverviewFirst: Non-breaking UpdatesSecond: Breaking UpdatesNon-Breaking UpdatesUpgrade to React v16.8Upgrade to @reach/router v1.3.3Update route components to use hooksAdd a LocationProviderBreaking updatesInstall React Router v6Update LocationProvider to BrowserRouterUpdate Router to RoutesUpdate default route prop<Redirect/>, redirectTo, isRedirect<Link getProps />useMatch<Match /><ServerLocation />Feedback!On this pageIntroductionUpgrading OverviewFirst: Non-breaking UpdatesSecond: Breaking UpdatesNon-Breaking UpdatesUpgrade to React v16.8Upgrade to @reach/router v1.3.3Update route components to use hooksAdd a LocationProviderBreaking updatesInstall React Router v6Update LocationProvider to BrowserRouterUpdate Router to RoutesUpdate default route prop<Redirect/>, redirectTo, isRedirect<Link getProps />useMatch<Match /><ServerLocation />Feedback!Migrating from Reach Router to React Router v6
This page is a work-in-progress. Please let us know where it
lacks so we can make the migration as smooth as possible!
Introduction
When we set out to build React Router v6, from the perspective of @reach/router users, we had these goals:

Keep the bundle size low (turns out we got it smaller than @reach/router)
Keep the best parts of @reach/router (nested routes, and a simplified API via ranked path matching and navigate)
Update the API to be idiomatic with modern React (AKA hooks).
Provide better support for Concurrent Mode and Suspense.
Stop doing not-good-enough focus management by default.

If we were to make a @reach/router v2, it would look pretty much exactly like React Router v6. So, the next version of @reach/router is React Router v6. In other words, there will be no @reach/router v2, because it would be the same as React Router v6.
A lot of the API is actually identical between @reach/router 1.3 and React Router v6:

Routes are ranked and matched
The nested route config is there
navigate has the same signature
Link has the same signature
All the hooks in 1.3 are identical (or nearly identical)

Most of the changes are just some renames. If you happen to write a codemod, please share it with us and we'll add it to this guide!
Upgrading Overview
In this guide we'll show you how to upgrade each piece of your routing code. We'll do it incrementally so you can make some changes, ship, and then get back to migrating again when it's convenient. We'll also discuss a little bit about "why" the changes were made, what might look like a simple rename actually has bigger reasons behind it.
First: Non-breaking Updates
We highly encourage you to do the following updates to your code before migrating to React Router v6. These changes don't have to be done all at once across your app, you can simply update one line, commit, and ship. Doing this will greatly reduce the effort when you get to the breaking changes in React Router v6.

Upgrade to React v16.8 or greater
Upgrade to @reach/router v1.3
Update route components to access data from hooks
Add a <LocationProvider/> to the top of the app

Second: Breaking Updates
The following changes need to be done all at once across your app.


Upgrade to React Router v6
Update all <Router> elements to <Routes>
Change <RouteElement default/> to <RouteElement path="*" />
Fix <Redirect />
Implement <Link getProps /> with hooks
Update useMatch, params are on match.params
Change ServerLocation to StaticRouter

Non-Breaking Updates
Upgrade to React v16.8
React Router v6 makes heavy use of React
hooks, so you'll need to be on
React 16.8 or greater before attempting the upgrade to React Router v6.
Once you've upgraded to React 16.8, you should deploy your app. Then you can
come back later and pick up where you left off.
Upgrade to @reach/router v1.3.3
You should be able to simply install v1.3.3 and then deploy your app.
npm install @reach/router@latest

Update route components to use hooks
You can do this step one route component at a time, commit, and deploy. You don't need to update the entire app at once.
In @reach/router v1.3 we added hooks to access route data in preparation for React Router v6. If you do this first you'll have a lot less to do when you upgrade to React Router v6.
// @reach/router v1.2
<Router>
  <User path="users/:userId/grades/:assignmentId" />
</Router>;

function User(props) {
  let {
    // route params were accessed from props
    userId,
    assignmentId,

    // as well as location and navigate
    location,
    navigate,
  } = props;

  // ...
}

// @reach/router v1.3 and React Router v6
import {
  useParams,
  useLocation,
  useNavigate,
} from "@reach/router";

function User() {
  // everything comes from a specific hook now
  let { userId, assignmentId } = useParams();
  let location = useLocation();
  let navigate = useNavigate();
  // ...
}

Justification
All of this data lives on context already, but accessing it from there was awkward for application code so we dumped it into your props. Hooks made accessing data from context simple so we no longer need to pollute your props with route information.
Not polluting props also helps with TypeScript a bit and also prevents you from wondering where a prop came from when looking at a component. If you're using data from the router, it's completely clear now.
Also, as a page grows, you naturally break it into multiple components and end up "prop drilling" that data all the way down the tree. Now you can access the route data anywhere in the tree. Not only is it more convenient, but it makes creating router-centric composable abstractions possible. If a custom hook needs the location, it can now simply ask for it with useLocation() etc..
Add a LocationProvider
While @reach/router doesn't require a location provider at the top of the application tree, React Router v6 does, so might as well get ready for that now.
// before
ReactDOM.render(<App />, el);

// after
import { LocationProvider } from "@reach/router";

ReactDOM.render(
  <LocationProvider>
    <App />
  </LocationProvider>,
  el
);

Justification:
@reach/router uses a global, default history instance that has side effects in the module, which prevents the ability to tree-shake the module whether you use the global or not. Additionally, React Router provides other history types (like hash history) that @reach/router doesn't, so it always requires a top-level location provider (in React Router these are <BrowserRouter/> and friends).
Also, various modules like Router, Link and useLocation rendered outside a <LocationProvider/> set up their own URL listener. It's generally not a problem, but every little bit counts. Putting a <LocationProvider /> at the top allows the app to have a single URL listener.
Breaking updates
This next group of updates need to be done all at once. Fortunately most of it is just a simple rename.
You can pull a trick though and use both routers at the same time as you migrate, but you should absolutely not ship your app in this state because they are not interoperable. Your links from one won't work for the other. However, it is nice to be able to make a change and refresh the page to see that you did that one step correctly.
Install React Router v6
npm install react-router@6 react-router-dom@6

Update LocationProvider to BrowserRouter
// @reach/router
import { LocationProvider } from "@reach/router";

ReactDOM.render(
  <LocationProvider>
    <App />
  </LocationProvider>,
  el
);

// React Router v6
import { BrowserRouter } from "react-router-dom";

ReactDOM.render(
  <BrowserRouter>
    <App />
  </BrowserRouter>,
  el
);

Update Router to Routes
You may have more than one, but usually there's just one somewhere near the top of your app. If you have multiple, go ahead and do this for each one.
// @reach/router
import { Router } from "@reach/router";

<Router>
  <Home path="/" />
  {/* ... */}
</Router>;

// React Router v6
import { Routes, Route } from "react-router-dom";

<Routes>
  <Route path="/" element={<Home />} />
  {/* ... */}
</Routes>;

Update default route prop
The default prop told @reach/router to use that route if no other routes matched. In React Router v6 you can explain this behavior with a wildcard path.
// @reach/router
<Router>
  <Home path="/" />
  <NotFound default />
</Router>

// React Router v6
<Routes>
  <Route path="/" element={<Home />} />
  <Route path="*" element={<NotFound />} />
</Routes>

<Redirect/>, redirectTo, isRedirect
Whew ... buckle up for this one. And please save your tomatoes for a homemade margherita pizza instead of throwing them at us.
We have removed the ability to redirect from React Router. So this means there is no <Redirect/>, redirectTo, or isRedirect, and no replacement APIs either. Please keep reading 😅
Don't confuse redirects with navigating while the user interacts with your app. Navigating in response to user interactions is still supported. When we talk about redirects, we're talking about redirecting while matching:
<Router>
  <Home path="/" />
  <Users path="/events" />
  <Redirect from="/dashboard" to="/events" />
</Router>

The way redirects work in @reach/router was a bit of an experiment. It "throws" redirects and catches it with componentDidCatch. This was cool because it caused the entire render tree to stop, and then start over with the new location. Discussions with the React team years ago when we first shipped this project led us to give it a shot.
After bumping into issues (like app level componentDidCatch's needing to rethrow the redirect), we've decided not to do that anymore in React Router v6.
But we've gone a step farther and concluded that redirects are not even the job of React Router. Your dynamic web server or static file server should be handling this and sending an appropriate response status code like 301 or 302.
Having the ability to redirect while matching in React Router at best requires you to configure the redirects in two places (your server and your routes) and at worst encouraged people to only do it in React Router--which doesn't send a status code at all.
We use firebase hosting a lot, so as an example here's how we'd update one of our apps:
// @reach/router
<Router>
  <Home path="/" />
  <Users path="/events" />
  <Redirect from="/dashboard" to="/events" />
</Router>

// React Router v6
// firebase.json config file
{
  // ...
  "hosting": {
    "redirects": [
      {
        "source": "/dashboard",
        "destination": "/events",
        "type": 301
      }
    ]
  }
}

This works whether we're server rendering with a serverless function, or if we're using it as a static file server only. All web hosting services provide a way to configure this.
What about clicking Links that aren't updated?
If your app has a <Link to="/events" /> still hanging around and the user
clicks it, the server isn't involved since you're using a client-side router.
You'll need to be more diligent about updating your links 😬.
Alternatively, if you want to allow for outdated links, and you realize you need to configure your redirects on both the client and the server, go ahead and copy and paste the Redirect component we were about to ship but then deleted.
import { useEffect } from "react";
import { useNavigate } from "react-router-dom";

function Redirect({ to }) {
  let navigate = useNavigate();
  useEffect(() => {
    navigate(to);
  });
  return null;
}

// usage
<Routes>
  <Route path="/" element={<Home />} />
  <Route path="/events" element={<Users />} />
  <Route
    path="/dashboard"
    element={<Redirect to="/events" />}
  />
</Routes>;

Justification
We figured by not providing any redirect API at all, people will be more likely to configure them correctly. We've been accidentally encouraging bad practice for years now and would like to stop 🙈.
<Link getProps />
This prop getter was useful for styling links as "active". Deciding if a link is active is kind of subjective. Sometimes you want it to be active if the URL matches exactly, sometimes you want it active if it matches partially, and there are even more edge cases involving search params and location state.
// @reach/router
function SomeCustomLink() {
  return (
    <Link
      to="/some/where/cool"
      getProps={(obj) => {
        let {
          isCurrent,
          isPartiallyCurrent,
          href,
          location,
        } = obj;
        // do what you will
      }}
    />
  );
}

// React Router
import { useLocation, useMatch } from "react-router-dom";

function SomeCustomLink() {
  let to = "/some/where/cool";
  let match = useMatch(to);
  let { isExact } = useMatch(to);
  let location = useLocation();
  return <Link to={to} />;
}

Let's look at some less general examples.
// A custom nav link that is active when the URL matches the link's href exactly

// @reach/router
function ExactNavLink(props) {
  const isActive = ({ isCurrent }) => {
    return isCurrent ? { className: "active" } : {};
  };
  return <Link getProps={isActive} {...props} />;
}

// React Router v6
function ExactNavLink(props) {
  return (
    <Link
      // If you only need the active state for styling without
      // overriding the default isActive state, we provide it as
      // a named argument in a function that can be passed to
      // either `className` or `style` props
      className={({ isActive }) =>
        isActive ? "active" : ""
      }
      {...props}
    />
  );
}

// A link that is active when itself or deeper routes are current

// @reach/router
function PartialNavLink(props) {
  const isPartiallyActive = ({ isPartiallyCurrent }) => {
    return isPartiallyCurrent
      ? { className: "active" }
      : {};
  };
  return <Link getProps={isPartiallyActive} {...props} />;
}

// React Router v6
function PartialNavLink(props) {
  // add the wild card to match deeper URLs
  let match = useMatch(props.to + "/*");
  return (
    <Link className={match ? "active" : ""} {...props} />
  );
}

Justification
"Prop getters" are clunky and can almost always be replaced with a hook. This also allows you to use the other hooks, like useLocation, and do even more custom things, like making a link active with a search string:
function RecentPostsLink(props) {
  let match = useMatch("/posts");
  let location = useLocation();
  let isActive =
    match && location.search === "?view=recent";
  return (
    <Link className={isActive ? "active" : ""}>Recent</Link>
  );
}

useMatch
The signature of useMatch is slightly different in React Router v6.
// @reach/router
let {
  uri,
  path,

  // params are merged into the object with uri and path
  eventId,
} = useMatch("/events/:eventId");

// React Router v6
let {
  url,
  path,

  // params get their own key on the match
  params: { eventId },
} = useMatch("/events/:eventId");

Also note the change from uri -> url.
Justification
Just feels cleaner to have the params be separate from URL and path.
Also, nobody knows the difference between URL and URI, so we didn't want to start a bunch of pedantic arguments about it. React Router always called it URL, and it's got more production apps, so we used URL instead of URI.
<Match />
There is no <Match/> component in React Router v6. It used render props to compose behavior, but we've got hooks now.
If you like it, or just don't want to update your code, it's easy to backport:
function Match({ path, children }) {
  let match = useMatch(path);
  let location = useLocation();
  let navigate = useNavigate();
  return children({ match, location, navigate });
}

Justification
Render props are kinda gross (ew!) now that we have hooks.
<ServerLocation />
Really simple rename here:
// @reach/router
import { ServerLocation } from "@reach/router";

createServer((req, res) => {
  let markup = ReactDOMServer.renderToString(
    <ServerLocation url={req.url}>
      <App />
    </ServerLocation>
  );
  req.send(markup);
});

// React Router v6
// note the import path from react-router-dom/server!
import { StaticRouter } from "react-router-dom/server";

createServer((req, res) => {
  let markup = ReactDOMServer.renderToString(
    <StaticRouter location={req.url}>
      <App />
    </StaticRouter>
  );
  req.send(markup);
});

Feedback!
Please let us know if this guide helped:
Open a Pull Request: Please add any migration we missed that you needed.
General Feedback: @remix_run on Twitter, or email hello@remix.run.
Thanks!© Remix Software, Inc.•Brand•Docs and examples CC 4.0

